// DO NOT EDIT; THIS FILE WAS GENERATED BY generate_math.py
#ifndef PSHINE_MATH_H_
#define PSHINE_MATH_H_
#include <stddef.h>
#include <string.h>
#include <math.h>

#define MATH_FN_ static inline
#define MATH_FAST_FN_ MATH_FN_

static const double π = 3.141592653589793;
static const double euler = 2.718281828459045;
static const double τ = 6.283185307179586;
static const float float_pinfty = +0x1.fffffep+127f;
static const float float_ninfty = -0x1.fffffep+127f;



/// Return the element-wise minimum of two values.
MATH_FN_ float minf(float a, float b) { return a < b ? a : b; }
/// Return the element-wise maximum of two values.
MATH_FN_ float maxf(float a, float b) { return a > b ? a : b; }
/// Return the element-wise clamped components of a value.
MATH_FN_ float clampf(float x, float a, float b) { return minf(maxf(x, a), b); }
/// Return the linear interpolation of two values by a scalar.
MATH_FN_ float lerpf(float a, float b, float t) { return a * (1 - t) + b * t; }

/// A 2-dimensional vector of floats.
typedef union {
	struct { float x, y; };
	struct { float r, g; };
	float vs[2];
} float2;

/// Create a vector with all components taken from the arguments.
MATH_FN_ float2 float2xy(float x, float y) { return (float2){{ x, y }}; }
/// Create a vector with all components taken from the arguments.
MATH_FN_ float2 float2rg(float r, float g) { return (float2){{ r, g }}; }
/// Create a vector with all components taken from the specified array.
MATH_FN_ float2 float2vs(const float vs[2]) { return (float2){{ vs[0], vs[1] }}; }
/// Create a vector with all components equal to the specified value.
MATH_FN_ float2 float2v(float v) { return (float2){{ v, v }}; }
/// Create a vector with all components equal to 0.
MATH_FN_ float2 float2v0() { return float2v(0); }

/// Return the negative vector.
MATH_FN_ float2 float2neg(float2 v) { return (float2){{ - v.vs[0], - v.vs[1] }}; }
/// Return the sum of two vectors.
MATH_FN_ float2 float2add(float2 a, float2 b) { return (float2){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1] }}; }
/// Return the difference of two vectors.
MATH_FN_ float2 float2sub(float2 a, float2 b) { return (float2){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1] }}; }
/// Return the product of a vector and a scalar.
MATH_FN_ float2 float2mul(float2 v, float s) { return (float2){{ v.vs[0] * s, v.vs[1] * s }}; }
/// Return the vector divided by a scalar.
MATH_FN_ float2 float2div(float2 v, float s) { return (float2){{ v.vs[0] / s, v.vs[1] / s }}; }
/// Return the dot product of two vectors.
MATH_FN_ float float2dot(float2 a, float2 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1]; }
/// Return the squared magnitude of a vector.
MATH_FN_ float float2mag2(float2 v) { return float2dot(v, v); }
/// Return the magnitude of a vector.
MATH_FN_ float float2mag(float2 v) { return sqrtf(float2mag2(v)); }
/// Return the normalized vector, or the zero-vector, if the original is also a zero-vector.
MATH_FN_ float2 float2norm(float2 v) {
	float m = float2mag2(v);
	if (fabsf(m) <= 0.000001f) return (float2){};
	return float2div(v, sqrtf(m));
}

/// Return the element-wise minimum of two values.
MATH_FN_ float2 float2min(float2 a, float2 b) { return (float2){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1] }}; }
/// Return the element-wise maximum of two values.
MATH_FN_ float2 float2max(float2 a, float2 b) { return (float2){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1] }}; }
/// Return the element-wise clamped components of a value.
MATH_FN_ float2 float2clamp(float2 x, float2 a, float2 b) { return float2min(float2max(x, a), b); }
/// Return the linear interpolation of two values by a scalar.
MATH_FN_ float2 float2lerp(float2 a, float2 b, float t) { return float2add(float2mul(a, (1 - t)), float2mul(b, t)); }

/// A 3-dimensional vector of floats.
typedef union {
	struct { float x, y, z; };
	struct { float r, g, b; };
	float vs[3];
} float3;

/// Create a vector with all components taken from the arguments.
MATH_FN_ float3 float3xyz(float x, float y, float z) { return (float3){{ x, y, z }}; }
/// Create a vector with all components taken from the arguments.
MATH_FN_ float3 float3rgb(float r, float g, float b) { return (float3){{ r, g, b }}; }
/// Create a vector with all components taken from the specified array.
MATH_FN_ float3 float3vs(const float vs[3]) { return (float3){{ vs[0], vs[1], vs[2] }}; }
/// Create a vector with all components equal to the specified value.
MATH_FN_ float3 float3v(float v) { return (float3){{ v, v, v }}; }
/// Create a vector with all components equal to 0.
MATH_FN_ float3 float3v0() { return float3v(0); }

/// Return the negative vector.
MATH_FN_ float3 float3neg(float3 v) { return (float3){{ - v.vs[0], - v.vs[1], - v.vs[2] }}; }
/// Return the sum of two vectors.
MATH_FN_ float3 float3add(float3 a, float3 b) { return (float3){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1], a.vs[2] + b.vs[2] }}; }
/// Return the difference of two vectors.
MATH_FN_ float3 float3sub(float3 a, float3 b) { return (float3){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1], a.vs[2] - b.vs[2] }}; }
/// Return the product of a vector and a scalar.
MATH_FN_ float3 float3mul(float3 v, float s) { return (float3){{ v.vs[0] * s, v.vs[1] * s, v.vs[2] * s }}; }
/// Return the vector divided by a scalar.
MATH_FN_ float3 float3div(float3 v, float s) { return (float3){{ v.vs[0] / s, v.vs[1] / s, v.vs[2] / s }}; }
/// Return the dot product of two vectors.
MATH_FN_ float float3dot(float3 a, float3 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1] + a.vs[2] * b.vs[2]; }
/// Return the squared magnitude of a vector.
MATH_FN_ float float3mag2(float3 v) { return float3dot(v, v); }
/// Return the magnitude of a vector.
MATH_FN_ float float3mag(float3 v) { return sqrtf(float3mag2(v)); }
/// Return the normalized vector, or the zero-vector, if the original is also a zero-vector.
MATH_FN_ float3 float3norm(float3 v) {
	float m = float3mag2(v);
	if (fabsf(m) <= 0.000001f) return (float3){};
	return float3div(v, sqrtf(m));
}

/// Return the cross product of two vectors.
MATH_FN_ float3 float3cross(float3 a, float3 b) {
	return float3xyz(
		a.y * b.z - a.z * b.y,
		a.z * b.x - a.x * b.z,
		a.x * b.y - a.y * b.x
	);
}

/// Return the element-wise minimum of two values.
MATH_FN_ float3 float3min(float3 a, float3 b) { return (float3){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] < b.vs[2] ? a.vs[2] : b.vs[2] }}; }
/// Return the element-wise maximum of two values.
MATH_FN_ float3 float3max(float3 a, float3 b) { return (float3){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] > b.vs[2] ? a.vs[2] : b.vs[2] }}; }
/// Return the element-wise clamped components of a value.
MATH_FN_ float3 float3clamp(float3 x, float3 a, float3 b) { return float3min(float3max(x, a), b); }
/// Return the linear interpolation of two values by a scalar.
MATH_FN_ float3 float3lerp(float3 a, float3 b, float t) { return float3add(float3mul(a, (1 - t)), float3mul(b, t)); }

/// A 4-dimensional vector of floats.
typedef union {
	struct { float x, y, z, w; };
	struct { float r, g, b, a; };
	float vs[4];
} float4;

/// Create a vector with all components taken from the arguments.
MATH_FN_ float4 float4xyzw(float x, float y, float z, float w) { return (float4){{ x, y, z, w }}; }
/// Create a vector with all components taken from the arguments.
MATH_FN_ float4 float4rgba(float r, float g, float b, float a) { return (float4){{ r, g, b, a }}; }
/// Create a vector with all components taken from the specified array.
MATH_FN_ float4 float4vs(const float vs[4]) { return (float4){{ vs[0], vs[1], vs[2], vs[3] }}; }
/// Create a vector with all components equal to the specified value.
MATH_FN_ float4 float4v(float v) { return (float4){{ v, v, v, v }}; }
/// Create a vector with all components equal to 0.
MATH_FN_ float4 float4v0() { return float4v(0); }

/// Create a 4-vector from a 3-vector and the w component.
MATH_FN_ float4 float4xyz3w(float3 xyz, float w) { return (float4){{ xyz.x, xyz.y, xyz.z, w }}; }

/// Return the negative vector.
MATH_FN_ float4 float4neg(float4 v) { return (float4){{ - v.vs[0], - v.vs[1], - v.vs[2], - v.vs[3] }}; }
/// Return the sum of two vectors.
MATH_FN_ float4 float4add(float4 a, float4 b) { return (float4){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1], a.vs[2] + b.vs[2], a.vs[3] + b.vs[3] }}; }
/// Return the difference of two vectors.
MATH_FN_ float4 float4sub(float4 a, float4 b) { return (float4){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1], a.vs[2] - b.vs[2], a.vs[3] - b.vs[3] }}; }
/// Return the product of a vector and a scalar.
MATH_FN_ float4 float4mul(float4 v, float s) { return (float4){{ v.vs[0] * s, v.vs[1] * s, v.vs[2] * s, v.vs[3] * s }}; }
/// Return the vector divided by a scalar.
MATH_FN_ float4 float4div(float4 v, float s) { return (float4){{ v.vs[0] / s, v.vs[1] / s, v.vs[2] / s, v.vs[3] / s }}; }
/// Return the dot product of two vectors.
MATH_FN_ float float4dot(float4 a, float4 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1] + a.vs[2] * b.vs[2] + a.vs[3] * b.vs[3]; }
/// Return the squared magnitude of a vector.
MATH_FN_ float float4mag2(float4 v) { return float4dot(v, v); }
/// Return the magnitude of a vector.
MATH_FN_ float float4mag(float4 v) { return sqrtf(float4mag2(v)); }
/// Return the normalized vector, or the zero-vector, if the original is also a zero-vector.
MATH_FN_ float4 float4norm(float4 v) {
	float m = float4mag2(v);
	if (fabsf(m) <= 0.000001f) return (float4){};
	return float4div(v, sqrtf(m));
}

/// Return the element-wise minimum of two values.
MATH_FN_ float4 float4min(float4 a, float4 b) { return (float4){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] < b.vs[2] ? a.vs[2] : b.vs[2], a.vs[3] < b.vs[3] ? a.vs[3] : b.vs[3] }}; }
/// Return the element-wise maximum of two values.
MATH_FN_ float4 float4max(float4 a, float4 b) { return (float4){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] > b.vs[2] ? a.vs[2] : b.vs[2], a.vs[3] > b.vs[3] ? a.vs[3] : b.vs[3] }}; }
/// Return the element-wise clamped components of a value.
MATH_FN_ float4 float4clamp(float4 x, float4 a, float4 b) { return float4min(float4max(x, a), b); }
/// Return the linear interpolation of two values by a scalar.
MATH_FN_ float4 float4lerp(float4 a, float4 b, float t) { return float4add(float4mul(a, (1 - t)), float4mul(b, t)); }
/// A float rotor, representing rotation in 3D space.
typedef union {
	struct { float s, xy, yz, zx; };
	float vs[4];
} floatR;

/// Create a rotor from a scalar, the xy bivector, the yz bivector, and the zx bivector.
MATH_FN_ floatR floatRwxyz(float w, float x, float y, float z) { return (floatR){{ w, x, y, z }}; }
/// Create a rotor with all components taken from the arguments.
MATH_FN_ floatR floatRvs(const float vs[4]) { return (floatR){{ vs[0], vs[1], vs[2], vs[3] }}; }
/// Create a rotor with all components equal to the specified value.
MATH_FN_ floatR floatRv(float v) { return (floatR){{ v, v, v, v }}; }
/// Create a rotor with all components equal to 0.
MATH_FN_ floatR floatRv0() { return floatRv(0); }
	
/// Create a rotor that is a combination of two rotors.
MATH_FN_ floatR floatRcombine(floatR a, floatR b) {
	floatR result = {};
	result.s  = a.s * b.s  - a.xy * b.xy - a.yz * b.yz - a.zx * b.zx;
	result.xy = a.s * b.xy + a.xy * b.s  - a.yz * b.zx + a.zx * b.yz;
	result.yz = a.s * b.yz + a.xy * b.zx + a.yz * b.s  - a.zx * b.xy;
	result.zx = a.s * b.zx - a.xy * b.yz + a.yz * b.xy + a.zx * b.s ;
	return result;
}
	
/// Create a rotor that is the inverse of the specified rotor.
MATH_FN_ floatR floatRinverse(floatR v) { return floatRwxyz(v.s, -v.xy, -v.yz, -v.zx); }

/// Apply a rotor to a vector.
MATH_FN_ float3 floatRapply(floatR r, float3 v) {
	const float S_x = r.s * v.x + r.xy * v.y - r.zx * v.z;
	const float S_y = r.s * v.y - r.xy * v.x + r.yz * v.z;
	const float S_z = r.s * v.z - r.yz * v.y + r.zx * v.x;
	const float S_xyz = r.xy * v.z + r.yz * v.x + r.zx * v.y;
	return float3xyz(
		S_x * r.s + S_y   * r.xy + S_xyz * r.yz - S_z   * r.zx,
		S_y * r.s - S_x   * r.xy + S_z   * r.yz + S_xyz * r.zx,
		S_z * r.s + S_xyz * r.xy - S_y   * r.yz + S_x   * r.zx
	);
}

/// Create a rotor from Euler angles, in Y-X-Z sequence.
/// First the aircraft does a yaw turn (Y), taxiing to the runway,
/// then it takes off, pitches (X), then rolls (Z).
MATH_FN_ floatR floatReuler(float pitch, float yaw, float roll) {
	const float cr = cosf(roll * 0.5);
	const float sr = sinf(roll * 0.5);
	const float cp = cosf(pitch * 0.5);
	const float sp = sinf(pitch * 0.5);
	const float cy = cosf(yaw * 0.5);
	const float sy = sinf(yaw * 0.5);

	// TODO: verify that the sequence is correct...
	return floatRwxyz(
		cr * cp * cy + sr * sp * sy,
		cr * sp * sy - sr * cp * cy,
		- cr * sp * cy - sr * cp * sy,
		sr * sp * cy - cr * cp * sy
	);
}

/// Create a rotor that transforms `from_dir` to `to_dir`.
MATH_FN_ floatR floatRfromto(float3 from_dir, float3 to_dir) {
	from_dir = float3norm(from_dir);
	to_dir = float3norm(to_dir);
	const float3 halfway = float3norm(float3add(from_dir, to_dir));
	return floatRwxyz(
		float3dot(from_dir, halfway),
		(halfway.x * from_dir.y) - (halfway.y * from_dir.x),
		(halfway.y * from_dir.z) - (halfway.z * from_dir.y),
		(halfway.z * from_dir.x) - (halfway.x * from_dir.z)
	);
}
	
MATH_FN_ floatR floatRnlerp(floatR lhs, floatR rhs, float t) {
	const float dot = lhs.s*rhs.s + lhs.xy*rhs.xy + lhs.yz*rhs.yz + lhs.zx*rhs.zx;
	if (dot < 0.0f) {
		rhs.s = -rhs.s;
		rhs.xy = -rhs.xy;
		rhs.yz = -rhs.yz;
		rhs.zx = -rhs.zx;
	}

	floatR r = {};
	r.s = lerpf(lhs.s, rhs.s, t);
	r.xy = lerpf(lhs.xy, rhs.xy, t);
	r.yz = lerpf(lhs.yz, rhs.yz, t);
	r.zx = lerpf(lhs.zx, rhs.zx, t);

	const float magnitude = sqrtf(r.s*r.s + r.xy*r.xy + r.yz*r.yz + r.zx*r.zx);
	r.s /= magnitude;
	r.xy /= magnitude;
	r.yz /= magnitude;
	r.zx /= magnitude;
	return r;
}

/// A 2 by 2 matrix of floats.
typedef union [[gnu::aligned(8)]] {
	struct { float vvs[4]; };
	struct { float vs[2][2]; };
	struct { float2 v2s[2]; };
} float2x2;

/// Multiply a matrix by a column vector. The matrix is treated as column-major.
MATH_FN_ float2 float2x2mulv(const float2x2 *m, float2 v) {
	return float2xy(
		m->vs[0][0] * v.x + m->vs[1][0] * v.y,
		m->vs[0][1] * v.x + m->vs[1][1] * v.y
	);
}


/// Set the specified matrix to the identity matrix.
MATH_FN_ void setfloat2x2iden(float2x2 *m) {
	memset(m->vs, 0, sizeof(m->vs));
	m->vs[0][0] = 1.0; m->vs[1][1] = 1.0;
}
/// Multiply a matrix by another matrix.
MATH_FN_ void float2x2mul(float2x2 *m1, const float2x2 *m2) {
	for (size_t i = 0; i < 2; ++i) {
		m1->v2s[i] = float2x2mulv(m2, m1->v2s[i]);
	}
	//for (size_t i = 0; i < 2; ++i) {
	//	for (size_t j = 0; j < 2; ++j) {
	//		res->vs[j][i] = 0;
	//		for (size_t k = 0; k < 2; ++k)
	//			res->vs[j][i] += m1->vs[k][i] * m2->vs[j][k];
	//	}
	//}
}


/// A 2 by 3 matrix of floats.
typedef union [[gnu::aligned(8)]] {
	struct { float vvs[6]; };
	struct { float vs[2][3]; };
	struct { float2 v2s[3]; };
} float2x3;

/// A 2 by 4 matrix of floats.
typedef union [[gnu::aligned(8)]] {
	struct { float vvs[8]; };
	struct { float vs[2][4]; };
	struct { float2 v2s[4]; };
} float2x4;

/// A 3 by 2 matrix of floats.
typedef union [[gnu::aligned(16)]] {
	struct { float vvs[6]; };
	struct { float vs[3][2]; };
	struct { float3 v3s[2]; };
} float3x2;

/// A 3 by 3 matrix of floats.
typedef union [[gnu::aligned(16)]] {
	struct { float vvs[9]; };
	struct { float vs[3][3]; };
	struct { float3 v3s[3]; };
} float3x3;

/// Multiply a matrix by a column vector. The matrix is treated as column-major.
MATH_FN_ float3 float3x3mulv(const float3x3 *m, float3 v) {
	return float3xyz(
		m->vs[0][0] * v.x + m->vs[1][0] * v.y + m->vs[2][0] * v.z,
		m->vs[0][1] * v.x + m->vs[1][1] * v.y + m->vs[2][1] * v.z,
		m->vs[0][2] * v.x + m->vs[1][2] * v.y + m->vs[2][2] * v.z
	);
}


/// Set the specified matrix to the identity matrix.
MATH_FN_ void setfloat3x3iden(float3x3 *m) {
	memset(m->vs, 0, sizeof(m->vs));
	m->vs[0][0] = 1.0; m->vs[1][1] = 1.0; m->vs[2][2] = 1.0;
}
/// Multiply a matrix by another matrix.
MATH_FN_ void float3x3mul(float3x3 *m1, const float3x3 *m2) {
	for (size_t i = 0; i < 3; ++i) {
		m1->v3s[i] = float3x3mulv(m2, m1->v3s[i]);
	}
	//for (size_t i = 0; i < 3; ++i) {
	//	for (size_t j = 0; j < 3; ++j) {
	//		res->vs[j][i] = 0;
	//		for (size_t k = 0; k < 3; ++k)
	//			res->vs[j][i] += m1->vs[k][i] * m2->vs[j][k];
	//	}
	//}
}


/// A 3 by 4 matrix of floats.
typedef union [[gnu::aligned(16)]] {
	struct { float vvs[12]; };
	struct { float vs[3][4]; };
	struct { float3 v3s[4]; };
} float3x4;

/// A 4 by 2 matrix of floats.
typedef union [[gnu::aligned(16)]] {
	struct { float vvs[8]; };
	struct { float vs[4][2]; };
	struct { float4 v4s[2]; };
} float4x2;

/// A 4 by 3 matrix of floats.
typedef union [[gnu::aligned(16)]] {
	struct { float vvs[12]; };
	struct { float vs[4][3]; };
	struct { float4 v4s[3]; };
} float4x3;

/// A 4 by 4 matrix of floats.
typedef union [[gnu::aligned(16)]] {
	struct { float vvs[16]; };
	struct { float vs[4][4]; };
	struct { float4 v4s[4]; };
} float4x4;

/// Multiply a matrix by a column vector. The matrix is treated as column-major.
MATH_FN_ float4 float4x4mulv(const float4x4 *m, float4 v) {
	return float4xyzw(
		m->vs[0][0] * v.x + m->vs[1][0] * v.y + m->vs[2][0] * v.z + m->vs[3][0] * v.w,
		m->vs[0][1] * v.x + m->vs[1][1] * v.y + m->vs[2][1] * v.z + m->vs[3][1] * v.w,
		m->vs[0][2] * v.x + m->vs[1][2] * v.y + m->vs[2][2] * v.z + m->vs[3][2] * v.w,
		m->vs[0][3] * v.x + m->vs[1][3] * v.y + m->vs[2][3] * v.z + m->vs[3][3] * v.w
	);
}


/// Set the specified matrix to the identity matrix.
MATH_FN_ void setfloat4x4iden(float4x4 *m) {
	memset(m->vs, 0, sizeof(m->vs));
	m->vs[0][0] = 1.0; m->vs[1][1] = 1.0; m->vs[2][2] = 1.0; m->vs[3][3] = 1.0;
}
/// Multiply a matrix by another matrix.
MATH_FN_ void float4x4mul(float4x4 *m1, const float4x4 *m2) {
	for (size_t i = 0; i < 4; ++i) {
		m1->v4s[i] = float4x4mulv(m2, m1->v4s[i]);
	}
	//for (size_t i = 0; i < 4; ++i) {
	//	for (size_t j = 0; j < 4; ++j) {
	//		res->vs[j][i] = 0;
	//		for (size_t k = 0; k < 4; ++k)
	//			res->vs[j][i] += m1->vs[k][i] * m2->vs[j][k];
	//	}
	//}
}


/// Multiply a matrix by an axis-angle transformation matrix.
MATH_FN_ void float3x3axisangle(float3x3 *m, float3 axis, float angle) {
	memset(m->vs, 0, sizeof(m->vs));
	float a = angle, c = cosf(a), s = sinf(a);
	axis = float3norm(axis);
	float3 t = float3mul(axis, 1 - c);

	float r00 = c + t.x * axis.x;
	float r01 = t.x * axis.y + s * axis.z;
	float r02 = t.x * axis.z - s * axis.y;

	float r10 = t.y * axis.x - s * axis.z;
	float r11 = c + t.y * axis.y;
	float r12 = t.y * axis.z + s * axis.x;

	float r20 = t.z * axis.x + s * axis.y;
	float r21 = t.z * axis.y - s * axis.x;
	float r22 = c + t.z * axis.z;

	float3x3 r;
	r.v3s[0] = float3add(float3add(float3mul(m->v3s[0], r00), float3mul(m->v3s[1], r01)), float3mul(m->v3s[2], r02));
	r.v3s[1] = float3add(float3add(float3mul(m->v3s[0], r10), float3mul(m->v3s[1], r11)), float3mul(m->v3s[2], r12));
	r.v3s[2] = float3add(float3add(float3mul(m->v3s[0], r20), float3mul(m->v3s[1], r21)), float3mul(m->v3s[2], r22));
	*m = r;
}
/// Create a 3x3 Euler angles rotation matrix.
MATH_FN_ void setfloat3x3rotation(float3x3 *m, float yaw, float pitch, float roll) {
	memset(m->vs, 0, sizeof(m->vs));
	float α = pitch, β = yaw, γ = roll;
	float sα = sinf(α), sβ = sinf(β), sγ = sinf(γ);
	float cα = cosf(α), cβ = cosf(β), cγ = cosf(γ);

	m->vs[0][0] = cβ * cγ;
	m->vs[1][0] = cβ * sγ;
	m->vs[2][0] = -sβ;
	m->vs[0][1] = sα * sβ * cγ - cα * sγ;
	m->vs[1][1] = sα * sβ * sγ + cα * cγ;
	m->vs[2][1] = sα * cβ;
	m->vs[0][2] = cα * sβ * cγ + sα * sγ;
	m->vs[1][2] = cα * sβ * sγ - sα * cγ;
	m->vs[2][2] = cα * cβ;
}
	
/// Create a 3x3 rotation matrix from a rotor.
MATH_FN_ void setfloat3x3rotationR(float3x3 *m, floatR r) {
	m->v3s[0] = floatRapply(r, float3xyz(1, 0, 0));
	m->v3s[1] = floatRapply(r, float3xyz(0, 1, 0));
	m->v3s[2] = floatRapply(r, float3xyz(0, 0, 1));
}

/// Create a 3x3 translation matrix.
MATH_FN_ void float4x4trans(float4x4 *m, float3 d) {
	float r[4] = {};
	r[0] += m->vs[0][0] * d.x; r[1] += m->vs[0][1] * d.x; r[2] += m->vs[0][2] * d.x; r[3] += m->vs[0][3] * d.x;
	r[0] += m->vs[1][0] * d.y; r[1] += m->vs[1][1] * d.y; r[2] += m->vs[1][2] * d.y; r[3] += m->vs[1][3] * d.y;
	r[0] += m->vs[2][0] * d.z; r[1] += m->vs[2][1] * d.z; r[2] += m->vs[2][2] * d.z; r[3] += m->vs[2][3] * d.z;
	m->vs[3][0] += r[0]; m->vs[3][1] += r[1]; m->vs[3][2] += r[2]; m->vs[3][3] += r[3];
}

/// Create a 3x3 scale matrix.
MATH_FN_ void float4x4scale(float4x4 *m, float3 s) {
	m->vs[0][0] *= s.x;
	m->vs[0][1] *= s.y;
	m->vs[0][2] *= s.z;
	m->vs[1][0] *= s.x;
	m->vs[1][1] *= s.y;
	m->vs[1][2] *= s.z;
	m->vs[2][0] *= s.x;
	m->vs[2][1] *= s.y;
	m->vs[2][2] *= s.z;
	m->vs[3][0] *= s.x;
	m->vs[3][1] *= s.y;
	m->vs[3][2] *= s.z;
}

/// Information returned by the perspective
/// projection matrix functions.
struct float4x4persp_info {
	/// The near plane extents.
	float2 plane;
	/// The distance of the near plane from the origin.
	float znear;
};

/// Set the specified matrix to a right-handed reversed-z perspective projection matrix.
MATH_FN_ struct float4x4persp_info setfloat4x4persp_rhoz(float4x4 *m, float fov, float aspect, float znear, float zfar) {
	// https://gist.github.com/pezcode/1609b61a1eedd207ec8c5acf6f94f53a
	memset(m->vs, 0, sizeof(m->vs));
	struct float4x4persp_info info;
	float t = tanf(fov * 0.5f * π / 180.0f);
	info.plane.y = t * znear;
	info.plane.x = info.plane.y * aspect;
	info.znear = znear;
	float k = znear / (znear - zfar);
	float g = 1.0 / t;
	m->vs[0][0] = g / aspect;
	m->vs[1][1] = -g;
	m->vs[2][2] = -k;
	m->vs[2][3] = 1.0;
	m->vs[3][2] = -znear * k;

	return info;
}

/// Set the specified matrix to a right-handed reversed-z infinite perspective projection matrix.
MATH_FN_ struct float4x4persp_info setfloat4x4persp_rhozi(float4x4 *m, float fov, float aspect, float znear) {
	// http://www.songho.ca/opengl/gl_projectionmatrix.html#perspective
	// https://computergraphics.stackexchange.com/a/12453
	// https://discourse.nphysics.org/t/reversed-z-and-infinite-zfar-in-projections/341/2
	memset(m->vs, 0, sizeof(m->vs));
	struct float4x4persp_info info;
	float t = tanf(fov * 0.5f * π / 180.0f);
	info.plane.y = t * znear;
	info.plane.x = info.plane.y * aspect;
	info.znear = znear;
	float g = 1.0f / t;

	m->vs[0][0] = g / aspect;
	m->vs[1][1] = -g;
	m->vs[3][2] = znear;
	m->vs[2][3] = 1.0f;

	return info;
}

/// Set the specified matrix to a perspective projection matrix.
MATH_FN_ struct float4x4persp_info setfloat4x4persp(float4x4 *m, float fov, float aspect, float znear) {
	// return setfloat4x4persp_rhoz(m, fov, aspect, znear, (float)1000.0);
	return setfloat4x4persp_rhozi(m, fov, aspect, znear);
}

/// Set the specified matrix to a view matrix, looking at `center` from `eye`,
/// with `up` being the upwards direction.
MATH_FN_ void setfloat4x4lookat(float4x4 *m, float3 eye, float3 center, float3 up) {
	memset(m->vs, 0, sizeof(m->vs));
	float3 f = float3norm(float3sub(center, eye));
	float3 s = float3norm(float3cross(up, f));
	float3 u = float3cross(f, s);

	m->vs[0][0] = s.x;
	m->vs[1][0] = s.y;
	m->vs[2][0] = s.z;
	m->vs[0][1] = u.x;
	m->vs[1][1] = u.y;
	m->vs[2][1] = u.z;
	m->vs[0][2] = f.x;
	m->vs[1][2] = f.y;
	m->vs[2][2] = f.z;
	m->vs[3][0] = -float3dot(s, eye);
	m->vs[3][1] = -float3dot(u, eye);
	m->vs[3][2] = -float3dot(f, eye);
	m->vs[3][3] = 1.0f;
}



// for Clang/LLVM, use intrinsics
#ifdef __clang__
// https://github.com/niswegmann/small-matrix-inverse
MATH_FN_ __attribute__((__always_inline__, __nodebug__)) void float4x4invert(const float * src, float * dst) {
	typedef __attribute__((__ext_vector_type__(4))) float float4;

	float4 row0, row1, row2, row3;
	float4 col0, col1, col2, col3;
	float4 det, tmp1;

	/* Load matrix: */

	col0 = ((float4 *) src)[0];
	col1 = ((float4 *) src)[1];
	col2 = ((float4 *) src)[2];
	col3 = ((float4 *) src)[3];

	/* Transpose: */

	tmp1 = __builtin_shufflevector(col0, col2, 0, 4, 1, 5);
	row1 = __builtin_shufflevector(col1, col3, 0, 4, 1, 5);

	row0 = __builtin_shufflevector(tmp1, row1, 0, 4, 1, 5);
	row1 = __builtin_shufflevector(tmp1, row1, 2, 6, 3, 7);

	tmp1 = __builtin_shufflevector(col0, col2, 2, 6, 3, 7);
	row3 = __builtin_shufflevector(col1, col3, 2, 6, 3, 7);

	row2 = __builtin_shufflevector(tmp1, row3, 0, 4, 1, 5);
	row3 = __builtin_shufflevector(tmp1, row3, 2, 6, 3, 7);

	/* Compute adjoint: */

	row1 = __builtin_shufflevector(row1, row1, 2, 3, 0, 1);
	row3 = __builtin_shufflevector(row3, row3, 2, 3, 0, 1);

	tmp1 = row2 * row3;
	tmp1 = __builtin_shufflevector(tmp1, tmp1, 1, 0, 7, 6);

	col0 = row1 * tmp1;
	col1 = row0 * tmp1;

	tmp1 = __builtin_shufflevector(tmp1, tmp1, 2, 3, 4, 5);

	col0 = row1 * tmp1 - col0;
	col1 = row0 * tmp1 - col1;
	col1 = __builtin_shufflevector(col1, col1, 2, 3, 4, 5);

	tmp1 = row1 * row2;
	tmp1 = __builtin_shufflevector(tmp1, tmp1, 1, 0, 7, 6);

	col0 = row3 * tmp1 + col0;
	col3 = row0 * tmp1;

	tmp1 = __builtin_shufflevector(tmp1, tmp1, 2, 3, 4, 5);

	col0 = col0 - row3 * tmp1;
	col3 = row0 * tmp1 - col3;
	col3 = __builtin_shufflevector(col3, col3, 2, 3, 4, 5);

	tmp1 = __builtin_shufflevector(row1, row1, 2, 3, 4, 5) * row3;
	tmp1 = __builtin_shufflevector(tmp1, tmp1, 1, 0, 7, 6);
	row2 = __builtin_shufflevector(row2, row2, 2, 3, 4, 5);

	col0 = row2 * tmp1 + col0;
	col2 = row0 * tmp1;

	tmp1 = __builtin_shufflevector(tmp1, tmp1, 2, 3, 4, 5);

	col0 = col0 - row2 * tmp1;
	col2 = row0 * tmp1 - col2;
	col2 = __builtin_shufflevector(col2, col2, 2, 3, 4, 5);

	tmp1 = row0 * row1;
	tmp1 = __builtin_shufflevector(tmp1, tmp1, 1, 0, 7, 6);

	col2 = row3 * tmp1 + col2;
	col3 = row2 * tmp1 - col3;

	tmp1 = __builtin_shufflevector(tmp1, tmp1, 2, 3, 4, 5);

	col2 = row3 * tmp1 - col2;
	col3 = col3 - row2 * tmp1;

	tmp1 = row0 * row3;
	tmp1 = __builtin_shufflevector(tmp1, tmp1, 1, 0, 7, 6);

	col1 = col1 - row2 * tmp1;
	col2 = row1 * tmp1 + col2;

	tmp1 = __builtin_shufflevector(tmp1, tmp1, 2, 3, 4, 5);

	col1 = row2 * tmp1 + col1;
	col2 = col2 - row1 * tmp1;

	tmp1 = row0 * row2;
	tmp1 = __builtin_shufflevector(tmp1, tmp1, 1, 0, 7, 6);

	col1 = row3 * tmp1 + col1;
	col3 = col3 - row1 * tmp1;

	tmp1 = __builtin_shufflevector(tmp1, tmp1, 2, 3, 4, 5);

	col1 = col1 - row3 * tmp1;
	col3 = row1 * tmp1 + col3;

	/* Compute determinant: */

	det = row0 * col0;
	det = __builtin_shufflevector(det, det, 2, 3, 4, 5) + det;
	det = __builtin_shufflevector(det, det, 1, 0, 7, 6) + det;

	/* Compute reciprocal of determinant: */

	det = 1.0f / det;

	/* Multiply matrix of cofactors with reciprocal of determinant: */

	col0 = col0 * det;
	col1 = col1 * det;
	col2 = col2 * det;
	col3 = col3 * det;

	/* Store inverted matrix: */

	((float4 *) dst)[0] = col0;
	((float4 *) dst)[1] = col1;
	((float4 *) dst)[2] = col2;
	((float4 *) dst)[3] = col3;
}

#else // defined(__clang__)

MATH_FN_ void float4x4invert(const float * src, float * dst)
{
	float det;

	/* Compute adjoint: */

	dst[0] =
		+ src[ 5] * src[10] * src[15]
		- src[ 5] * src[11] * src[14]
		- src[ 9] * src[ 6] * src[15]
		+ src[ 9] * src[ 7] * src[14]
		+ src[13] * src[ 6] * src[11]
		- src[13] * src[ 7] * src[10];

	dst[1] =
		- src[ 1] * src[10] * src[15]
		+ src[ 1] * src[11] * src[14]
		+ src[ 9] * src[ 2] * src[15]
		- src[ 9] * src[ 3] * src[14]
		- src[13] * src[ 2] * src[11]
		+ src[13] * src[ 3] * src[10];

	dst[2] =
		+ src[ 1] * src[ 6] * src[15]
		- src[ 1] * src[ 7] * src[14]
		- src[ 5] * src[ 2] * src[15]
		+ src[ 5] * src[ 3] * src[14]
		+ src[13] * src[ 2] * src[ 7]
		- src[13] * src[ 3] * src[ 6];

	dst[3] =
		- src[ 1] * src[ 6] * src[11]
		+ src[ 1] * src[ 7] * src[10]
		+ src[ 5] * src[ 2] * src[11]
		- src[ 5] * src[ 3] * src[10]
		- src[ 9] * src[ 2] * src[ 7]
		+ src[ 9] * src[ 3] * src[ 6];

	dst[4] =
		- src[ 4] * src[10] * src[15]
		+ src[ 4] * src[11] * src[14]
		+ src[ 8] * src[ 6] * src[15]
		- src[ 8] * src[ 7] * src[14]
		- src[12] * src[ 6] * src[11]
		+ src[12] * src[ 7] * src[10];

	dst[5] =
		+ src[ 0] * src[10] * src[15]
		- src[ 0] * src[11] * src[14]
		- src[ 8] * src[ 2] * src[15]
		+ src[ 8] * src[ 3] * src[14]
		+ src[12] * src[ 2] * src[11]
		- src[12] * src[ 3] * src[10];

	dst[6] =
		- src[ 0] * src[ 6] * src[15]
		+ src[ 0] * src[ 7] * src[14]
		+ src[ 4] * src[ 2] * src[15]
		- src[ 4] * src[ 3] * src[14]
		- src[12] * src[ 2] * src[ 7]
		+ src[12] * src[ 3] * src[ 6];

	dst[7] =
		+ src[ 0] * src[ 6] * src[11]
		- src[ 0] * src[ 7] * src[10]
		- src[ 4] * src[ 2] * src[11]
		+ src[ 4] * src[ 3] * src[10]
		+ src[ 8] * src[ 2] * src[ 7]
		- src[ 8] * src[ 3] * src[ 6];

	dst[8] =
		+ src[ 4] * src[ 9] * src[15]
		- src[ 4] * src[11] * src[13]
		- src[ 8] * src[ 5] * src[15]
		+ src[ 8] * src[ 7] * src[13]
		+ src[12] * src[ 5] * src[11]
		- src[12] * src[ 7] * src[ 9];

	dst[9] =
		- src[ 0] * src[ 9] * src[15]
		+ src[ 0] * src[11] * src[13]
		+ src[ 8] * src[ 1] * src[15]
		- src[ 8] * src[ 3] * src[13]
		- src[12] * src[ 1] * src[11]
		+ src[12] * src[ 3] * src[ 9];

	dst[10] =
		+ src[ 0] * src[ 5] * src[15]
		- src[ 0] * src[ 7] * src[13]
		- src[ 4] * src[ 1] * src[15]
		+ src[ 4] * src[ 3] * src[13]
		+ src[12] * src[ 1] * src[ 7]
		- src[12] * src[ 3] * src[ 5];

	dst[11] =
		- src[ 0] * src[ 5] * src[11]
		+ src[ 0] * src[ 7] * src[ 9]
		+ src[ 4] * src[ 1] * src[11]
		- src[ 4] * src[ 3] * src[ 9]
		- src[ 8] * src[ 1] * src[ 7]
		+ src[ 8] * src[ 3] * src[ 5];

	dst[12] =
		- src[ 4] * src[ 9] * src[14]
		+ src[ 4] * src[10] * src[13]
		+ src[ 8] * src[ 5] * src[14]
		- src[ 8] * src[ 6] * src[13]
		- src[12] * src[ 5] * src[10]
		+ src[12] * src[ 6] * src[ 9];

	dst[13] =
		+ src[ 0] * src[ 9] * src[14]
		- src[ 0] * src[10] * src[13]
		- src[ 8] * src[ 1] * src[14]
		+ src[ 8] * src[ 2] * src[13]
		+ src[12] * src[ 1] * src[10]
		- src[12] * src[ 2] * src[ 9];

	dst[14] =
		- src[ 0] * src[ 5] * src[14]
		+ src[ 0] * src[ 6] * src[13]
		+ src[ 4] * src[ 1] * src[14]
		- src[ 4] * src[ 2] * src[13]
		- src[12] * src[ 1] * src[ 6]
		+ src[12] * src[ 2] * src[ 5];

	dst[15] =
		+ src[ 0] * src[ 5] * src[10]
		- src[ 0] * src[ 6] * src[ 9]
		- src[ 4] * src[ 1] * src[10]
		+ src[ 4] * src[ 2] * src[ 9]
		+ src[ 8] * src[ 1] * src[ 6]
		- src[ 8] * src[ 2] * src[ 5];

	/* Compute determinant: */

	det = + src[0] * dst[0] + src[1] * dst[4] + src[2] * dst[8] + src[3] * dst[12];

	/* Multiply adjoint with reciprocal of determinant: */

	det = 1.0f / det;

	dst[ 0] *= det;
	dst[ 1] *= det;
	dst[ 2] *= det;
	dst[ 3] *= det;
	dst[ 4] *= det;
	dst[ 5] *= det;
	dst[ 6] *= det;
	dst[ 7] *= det;
	dst[ 8] *= det;
	dst[ 9] *= det;
	dst[10] *= det;
	dst[11] *= det;
	dst[12] *= det;
	dst[13] *= det;
	dst[14] *= det;
	dst[15] *= det;
}

#endif



/// Return the element-wise minimum of two values.
MATH_FN_ double mind(double a, double b) { return a < b ? a : b; }
/// Return the element-wise maximum of two values.
MATH_FN_ double maxd(double a, double b) { return a > b ? a : b; }
/// Return the element-wise clamped components of a value.
MATH_FN_ double clampd(double x, double a, double b) { return mind(maxd(x, a), b); }
/// Return the linear interpolation of two values by a scalar.
MATH_FN_ double lerpd(double a, double b, double t) { return a * (1 - t) + b * t; }

/// A 2-dimensional vector of doubles.
typedef union {
	struct { double x, y; };
	struct { double r, g; };
	double vs[2];
} double2;

/// Create a vector with all components taken from the arguments.
MATH_FN_ double2 double2xy(double x, double y) { return (double2){{ x, y }}; }
/// Create a vector with all components taken from the arguments.
MATH_FN_ double2 double2rg(double r, double g) { return (double2){{ r, g }}; }
/// Create a vector with all components taken from the specified array.
MATH_FN_ double2 double2vs(const double vs[2]) { return (double2){{ vs[0], vs[1] }}; }
/// Create a vector with all components equal to the specified value.
MATH_FN_ double2 double2v(double v) { return (double2){{ v, v }}; }
/// Create a vector with all components equal to 0.
MATH_FN_ double2 double2v0() { return double2v(0); }

/// Return the negative vector.
MATH_FN_ double2 double2neg(double2 v) { return (double2){{ - v.vs[0], - v.vs[1] }}; }
/// Return the sum of two vectors.
MATH_FN_ double2 double2add(double2 a, double2 b) { return (double2){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1] }}; }
/// Return the difference of two vectors.
MATH_FN_ double2 double2sub(double2 a, double2 b) { return (double2){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1] }}; }
/// Return the product of a vector and a scalar.
MATH_FN_ double2 double2mul(double2 v, double s) { return (double2){{ v.vs[0] * s, v.vs[1] * s }}; }
/// Return the vector divided by a scalar.
MATH_FN_ double2 double2div(double2 v, double s) { return (double2){{ v.vs[0] / s, v.vs[1] / s }}; }
/// Return the dot product of two vectors.
MATH_FN_ double double2dot(double2 a, double2 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1]; }
/// Return the squared magnitude of a vector.
MATH_FN_ double double2mag2(double2 v) { return double2dot(v, v); }
/// Return the magnitude of a vector.
MATH_FN_ double double2mag(double2 v) { return sqrt(double2mag2(v)); }
/// Return the normalized vector, or the zero-vector, if the original is also a zero-vector.
MATH_FN_ double2 double2norm(double2 v) {
	double m = double2mag2(v);
	if (fabs(m) <= 0.000000001) return (double2){};
	return double2div(v, sqrt(m));
}

/// Return the element-wise minimum of two values.
MATH_FN_ double2 double2min(double2 a, double2 b) { return (double2){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1] }}; }
/// Return the element-wise maximum of two values.
MATH_FN_ double2 double2max(double2 a, double2 b) { return (double2){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1] }}; }
/// Return the element-wise clamped components of a value.
MATH_FN_ double2 double2clamp(double2 x, double2 a, double2 b) { return double2min(double2max(x, a), b); }
/// Return the linear interpolation of two values by a scalar.
MATH_FN_ double2 double2lerp(double2 a, double2 b, double t) { return double2add(double2mul(a, (1 - t)), double2mul(b, t)); }

/// A 3-dimensional vector of doubles.
typedef union {
	struct { double x, y, z; };
	struct { double r, g, b; };
	double vs[3];
} double3;

/// Create a vector with all components taken from the arguments.
MATH_FN_ double3 double3xyz(double x, double y, double z) { return (double3){{ x, y, z }}; }
/// Create a vector with all components taken from the arguments.
MATH_FN_ double3 double3rgb(double r, double g, double b) { return (double3){{ r, g, b }}; }
/// Create a vector with all components taken from the specified array.
MATH_FN_ double3 double3vs(const double vs[3]) { return (double3){{ vs[0], vs[1], vs[2] }}; }
/// Create a vector with all components equal to the specified value.
MATH_FN_ double3 double3v(double v) { return (double3){{ v, v, v }}; }
/// Create a vector with all components equal to 0.
MATH_FN_ double3 double3v0() { return double3v(0); }

/// Return the negative vector.
MATH_FN_ double3 double3neg(double3 v) { return (double3){{ - v.vs[0], - v.vs[1], - v.vs[2] }}; }
/// Return the sum of two vectors.
MATH_FN_ double3 double3add(double3 a, double3 b) { return (double3){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1], a.vs[2] + b.vs[2] }}; }
/// Return the difference of two vectors.
MATH_FN_ double3 double3sub(double3 a, double3 b) { return (double3){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1], a.vs[2] - b.vs[2] }}; }
/// Return the product of a vector and a scalar.
MATH_FN_ double3 double3mul(double3 v, double s) { return (double3){{ v.vs[0] * s, v.vs[1] * s, v.vs[2] * s }}; }
/// Return the vector divided by a scalar.
MATH_FN_ double3 double3div(double3 v, double s) { return (double3){{ v.vs[0] / s, v.vs[1] / s, v.vs[2] / s }}; }
/// Return the dot product of two vectors.
MATH_FN_ double double3dot(double3 a, double3 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1] + a.vs[2] * b.vs[2]; }
/// Return the squared magnitude of a vector.
MATH_FN_ double double3mag2(double3 v) { return double3dot(v, v); }
/// Return the magnitude of a vector.
MATH_FN_ double double3mag(double3 v) { return sqrt(double3mag2(v)); }
/// Return the normalized vector, or the zero-vector, if the original is also a zero-vector.
MATH_FN_ double3 double3norm(double3 v) {
	double m = double3mag2(v);
	if (fabs(m) <= 0.000000001) return (double3){};
	return double3div(v, sqrt(m));
}

/// Return the cross product of two vectors.
MATH_FN_ double3 double3cross(double3 a, double3 b) {
	return double3xyz(
		a.y * b.z - a.z * b.y,
		a.z * b.x - a.x * b.z,
		a.x * b.y - a.y * b.x
	);
}

/// Return the element-wise minimum of two values.
MATH_FN_ double3 double3min(double3 a, double3 b) { return (double3){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] < b.vs[2] ? a.vs[2] : b.vs[2] }}; }
/// Return the element-wise maximum of two values.
MATH_FN_ double3 double3max(double3 a, double3 b) { return (double3){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] > b.vs[2] ? a.vs[2] : b.vs[2] }}; }
/// Return the element-wise clamped components of a value.
MATH_FN_ double3 double3clamp(double3 x, double3 a, double3 b) { return double3min(double3max(x, a), b); }
/// Return the linear interpolation of two values by a scalar.
MATH_FN_ double3 double3lerp(double3 a, double3 b, double t) { return double3add(double3mul(a, (1 - t)), double3mul(b, t)); }

/// A 4-dimensional vector of doubles.
typedef union {
	struct { double x, y, z, w; };
	struct { double r, g, b, a; };
	double vs[4];
} double4;

/// Create a vector with all components taken from the arguments.
MATH_FN_ double4 double4xyzw(double x, double y, double z, double w) { return (double4){{ x, y, z, w }}; }
/// Create a vector with all components taken from the arguments.
MATH_FN_ double4 double4rgba(double r, double g, double b, double a) { return (double4){{ r, g, b, a }}; }
/// Create a vector with all components taken from the specified array.
MATH_FN_ double4 double4vs(const double vs[4]) { return (double4){{ vs[0], vs[1], vs[2], vs[3] }}; }
/// Create a vector with all components equal to the specified value.
MATH_FN_ double4 double4v(double v) { return (double4){{ v, v, v, v }}; }
/// Create a vector with all components equal to 0.
MATH_FN_ double4 double4v0() { return double4v(0); }

/// Create a 4-vector from a 3-vector and the w component.
MATH_FN_ double4 double4xyz3w(double3 xyz, double w) { return (double4){{ xyz.x, xyz.y, xyz.z, w }}; }

/// Return the negative vector.
MATH_FN_ double4 double4neg(double4 v) { return (double4){{ - v.vs[0], - v.vs[1], - v.vs[2], - v.vs[3] }}; }
/// Return the sum of two vectors.
MATH_FN_ double4 double4add(double4 a, double4 b) { return (double4){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1], a.vs[2] + b.vs[2], a.vs[3] + b.vs[3] }}; }
/// Return the difference of two vectors.
MATH_FN_ double4 double4sub(double4 a, double4 b) { return (double4){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1], a.vs[2] - b.vs[2], a.vs[3] - b.vs[3] }}; }
/// Return the product of a vector and a scalar.
MATH_FN_ double4 double4mul(double4 v, double s) { return (double4){{ v.vs[0] * s, v.vs[1] * s, v.vs[2] * s, v.vs[3] * s }}; }
/// Return the vector divided by a scalar.
MATH_FN_ double4 double4div(double4 v, double s) { return (double4){{ v.vs[0] / s, v.vs[1] / s, v.vs[2] / s, v.vs[3] / s }}; }
/// Return the dot product of two vectors.
MATH_FN_ double double4dot(double4 a, double4 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1] + a.vs[2] * b.vs[2] + a.vs[3] * b.vs[3]; }
/// Return the squared magnitude of a vector.
MATH_FN_ double double4mag2(double4 v) { return double4dot(v, v); }
/// Return the magnitude of a vector.
MATH_FN_ double double4mag(double4 v) { return sqrt(double4mag2(v)); }
/// Return the normalized vector, or the zero-vector, if the original is also a zero-vector.
MATH_FN_ double4 double4norm(double4 v) {
	double m = double4mag2(v);
	if (fabs(m) <= 0.000000001) return (double4){};
	return double4div(v, sqrt(m));
}

/// Return the element-wise minimum of two values.
MATH_FN_ double4 double4min(double4 a, double4 b) { return (double4){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] < b.vs[2] ? a.vs[2] : b.vs[2], a.vs[3] < b.vs[3] ? a.vs[3] : b.vs[3] }}; }
/// Return the element-wise maximum of two values.
MATH_FN_ double4 double4max(double4 a, double4 b) { return (double4){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] > b.vs[2] ? a.vs[2] : b.vs[2], a.vs[3] > b.vs[3] ? a.vs[3] : b.vs[3] }}; }
/// Return the element-wise clamped components of a value.
MATH_FN_ double4 double4clamp(double4 x, double4 a, double4 b) { return double4min(double4max(x, a), b); }
/// Return the linear interpolation of two values by a scalar.
MATH_FN_ double4 double4lerp(double4 a, double4 b, double t) { return double4add(double4mul(a, (1 - t)), double4mul(b, t)); }
/// A double rotor, representing rotation in 3D space.
typedef union {
	struct { double s, xy, yz, zx; };
	double vs[4];
} doubleR;

/// Create a rotor from a scalar, the xy bivector, the yz bivector, and the zx bivector.
MATH_FN_ doubleR doubleRwxyz(double w, double x, double y, double z) { return (doubleR){{ w, x, y, z }}; }
/// Create a rotor with all components taken from the arguments.
MATH_FN_ doubleR doubleRvs(const double vs[4]) { return (doubleR){{ vs[0], vs[1], vs[2], vs[3] }}; }
/// Create a rotor with all components equal to the specified value.
MATH_FN_ doubleR doubleRv(double v) { return (doubleR){{ v, v, v, v }}; }
/// Create a rotor with all components equal to 0.
MATH_FN_ doubleR doubleRv0() { return doubleRv(0); }
	
/// Create a rotor that is a combination of two rotors.
MATH_FN_ doubleR doubleRcombine(doubleR a, doubleR b) {
	doubleR result = {};
	result.s  = a.s * b.s  - a.xy * b.xy - a.yz * b.yz - a.zx * b.zx;
	result.xy = a.s * b.xy + a.xy * b.s  - a.yz * b.zx + a.zx * b.yz;
	result.yz = a.s * b.yz + a.xy * b.zx + a.yz * b.s  - a.zx * b.xy;
	result.zx = a.s * b.zx - a.xy * b.yz + a.yz * b.xy + a.zx * b.s ;
	return result;
}
	
/// Create a rotor that is the inverse of the specified rotor.
MATH_FN_ doubleR doubleRinverse(doubleR v) { return doubleRwxyz(v.s, -v.xy, -v.yz, -v.zx); }

/// Apply a rotor to a vector.
MATH_FN_ double3 doubleRapply(doubleR r, double3 v) {
	const double S_x = r.s * v.x + r.xy * v.y - r.zx * v.z;
	const double S_y = r.s * v.y - r.xy * v.x + r.yz * v.z;
	const double S_z = r.s * v.z - r.yz * v.y + r.zx * v.x;
	const double S_xyz = r.xy * v.z + r.yz * v.x + r.zx * v.y;
	return double3xyz(
		S_x * r.s + S_y   * r.xy + S_xyz * r.yz - S_z   * r.zx,
		S_y * r.s - S_x   * r.xy + S_z   * r.yz + S_xyz * r.zx,
		S_z * r.s + S_xyz * r.xy - S_y   * r.yz + S_x   * r.zx
	);
}

/// Create a rotor from Euler angles, in Y-X-Z sequence.
/// First the aircraft does a yaw turn (Y), taxiing to the runway,
/// then it takes off, pitches (X), then rolls (Z).
MATH_FN_ doubleR doubleReuler(double pitch, double yaw, double roll) {
	const double cr = cos(roll * 0.5);
	const double sr = sin(roll * 0.5);
	const double cp = cos(pitch * 0.5);
	const double sp = sin(pitch * 0.5);
	const double cy = cos(yaw * 0.5);
	const double sy = sin(yaw * 0.5);

	// TODO: verify that the sequence is correct...
	return doubleRwxyz(
		cr * cp * cy + sr * sp * sy,
		cr * sp * sy - sr * cp * cy,
		- cr * sp * cy - sr * cp * sy,
		sr * sp * cy - cr * cp * sy
	);
}

/// Create a rotor that transforms `from_dir` to `to_dir`.
MATH_FN_ doubleR doubleRfromto(double3 from_dir, double3 to_dir) {
	from_dir = double3norm(from_dir);
	to_dir = double3norm(to_dir);
	const double3 halfway = double3norm(double3add(from_dir, to_dir));
	return doubleRwxyz(
		double3dot(from_dir, halfway),
		(halfway.x * from_dir.y) - (halfway.y * from_dir.x),
		(halfway.y * from_dir.z) - (halfway.z * from_dir.y),
		(halfway.z * from_dir.x) - (halfway.x * from_dir.z)
	);
}
	
MATH_FN_ doubleR doubleRnlerp(doubleR lhs, doubleR rhs, double t) {
	const float dot = lhs.s*rhs.s + lhs.xy*rhs.xy + lhs.yz*rhs.yz + lhs.zx*rhs.zx;
	if (dot < 0.0f) {
		rhs.s = -rhs.s;
		rhs.xy = -rhs.xy;
		rhs.yz = -rhs.yz;
		rhs.zx = -rhs.zx;
	}

	doubleR r = {};
	r.s = lerpd(lhs.s, rhs.s, t);
	r.xy = lerpd(lhs.xy, rhs.xy, t);
	r.yz = lerpd(lhs.yz, rhs.yz, t);
	r.zx = lerpd(lhs.zx, rhs.zx, t);

	const float magnitude = sqrt(r.s*r.s + r.xy*r.xy + r.yz*r.yz + r.zx*r.zx);
	r.s /= magnitude;
	r.xy /= magnitude;
	r.yz /= magnitude;
	r.zx /= magnitude;
	return r;
}

/// A 2 by 2 matrix of doubles.
typedef union [[gnu::aligned(8)]] {
	struct { double vvs[4]; };
	struct { double vs[2][2]; };
	struct { double2 v2s[2]; };
} double2x2;

/// Multiply a matrix by a column vector. The matrix is treated as column-major.
MATH_FN_ double2 double2x2mulv(const double2x2 *m, double2 v) {
	return double2xy(
		m->vs[0][0] * v.x + m->vs[1][0] * v.y,
		m->vs[0][1] * v.x + m->vs[1][1] * v.y
	);
}


/// Set the specified matrix to the identity matrix.
MATH_FN_ void setdouble2x2iden(double2x2 *m) {
	memset(m->vs, 0, sizeof(m->vs));
	m->vs[0][0] = 1.0; m->vs[1][1] = 1.0;
}
/// Multiply a matrix by another matrix.
MATH_FN_ void double2x2mul(double2x2 *m1, const double2x2 *m2) {
	for (size_t i = 0; i < 2; ++i) {
		m1->v2s[i] = double2x2mulv(m2, m1->v2s[i]);
	}
	//for (size_t i = 0; i < 2; ++i) {
	//	for (size_t j = 0; j < 2; ++j) {
	//		res->vs[j][i] = 0;
	//		for (size_t k = 0; k < 2; ++k)
	//			res->vs[j][i] += m1->vs[k][i] * m2->vs[j][k];
	//	}
	//}
}


/// A 2 by 3 matrix of doubles.
typedef union [[gnu::aligned(8)]] {
	struct { double vvs[6]; };
	struct { double vs[2][3]; };
	struct { double2 v2s[3]; };
} double2x3;

/// A 2 by 4 matrix of doubles.
typedef union [[gnu::aligned(8)]] {
	struct { double vvs[8]; };
	struct { double vs[2][4]; };
	struct { double2 v2s[4]; };
} double2x4;

/// A 3 by 2 matrix of doubles.
typedef union [[gnu::aligned(16)]] {
	struct { double vvs[6]; };
	struct { double vs[3][2]; };
	struct { double3 v3s[2]; };
} double3x2;

/// A 3 by 3 matrix of doubles.
typedef union [[gnu::aligned(16)]] {
	struct { double vvs[9]; };
	struct { double vs[3][3]; };
	struct { double3 v3s[3]; };
} double3x3;

/// Multiply a matrix by a column vector. The matrix is treated as column-major.
MATH_FN_ double3 double3x3mulv(const double3x3 *m, double3 v) {
	return double3xyz(
		m->vs[0][0] * v.x + m->vs[1][0] * v.y + m->vs[2][0] * v.z,
		m->vs[0][1] * v.x + m->vs[1][1] * v.y + m->vs[2][1] * v.z,
		m->vs[0][2] * v.x + m->vs[1][2] * v.y + m->vs[2][2] * v.z
	);
}


/// Set the specified matrix to the identity matrix.
MATH_FN_ void setdouble3x3iden(double3x3 *m) {
	memset(m->vs, 0, sizeof(m->vs));
	m->vs[0][0] = 1.0; m->vs[1][1] = 1.0; m->vs[2][2] = 1.0;
}
/// Multiply a matrix by another matrix.
MATH_FN_ void double3x3mul(double3x3 *m1, const double3x3 *m2) {
	for (size_t i = 0; i < 3; ++i) {
		m1->v3s[i] = double3x3mulv(m2, m1->v3s[i]);
	}
	//for (size_t i = 0; i < 3; ++i) {
	//	for (size_t j = 0; j < 3; ++j) {
	//		res->vs[j][i] = 0;
	//		for (size_t k = 0; k < 3; ++k)
	//			res->vs[j][i] += m1->vs[k][i] * m2->vs[j][k];
	//	}
	//}
}


/// A 3 by 4 matrix of doubles.
typedef union [[gnu::aligned(16)]] {
	struct { double vvs[12]; };
	struct { double vs[3][4]; };
	struct { double3 v3s[4]; };
} double3x4;

/// A 4 by 2 matrix of doubles.
typedef union [[gnu::aligned(16)]] {
	struct { double vvs[8]; };
	struct { double vs[4][2]; };
	struct { double4 v4s[2]; };
} double4x2;

/// A 4 by 3 matrix of doubles.
typedef union [[gnu::aligned(16)]] {
	struct { double vvs[12]; };
	struct { double vs[4][3]; };
	struct { double4 v4s[3]; };
} double4x3;

/// A 4 by 4 matrix of doubles.
typedef union [[gnu::aligned(16)]] {
	struct { double vvs[16]; };
	struct { double vs[4][4]; };
	struct { double4 v4s[4]; };
} double4x4;

/// Multiply a matrix by a column vector. The matrix is treated as column-major.
MATH_FN_ double4 double4x4mulv(const double4x4 *m, double4 v) {
	return double4xyzw(
		m->vs[0][0] * v.x + m->vs[1][0] * v.y + m->vs[2][0] * v.z + m->vs[3][0] * v.w,
		m->vs[0][1] * v.x + m->vs[1][1] * v.y + m->vs[2][1] * v.z + m->vs[3][1] * v.w,
		m->vs[0][2] * v.x + m->vs[1][2] * v.y + m->vs[2][2] * v.z + m->vs[3][2] * v.w,
		m->vs[0][3] * v.x + m->vs[1][3] * v.y + m->vs[2][3] * v.z + m->vs[3][3] * v.w
	);
}


/// Set the specified matrix to the identity matrix.
MATH_FN_ void setdouble4x4iden(double4x4 *m) {
	memset(m->vs, 0, sizeof(m->vs));
	m->vs[0][0] = 1.0; m->vs[1][1] = 1.0; m->vs[2][2] = 1.0; m->vs[3][3] = 1.0;
}
/// Multiply a matrix by another matrix.
MATH_FN_ void double4x4mul(double4x4 *m1, const double4x4 *m2) {
	for (size_t i = 0; i < 4; ++i) {
		m1->v4s[i] = double4x4mulv(m2, m1->v4s[i]);
	}
	//for (size_t i = 0; i < 4; ++i) {
	//	for (size_t j = 0; j < 4; ++j) {
	//		res->vs[j][i] = 0;
	//		for (size_t k = 0; k < 4; ++k)
	//			res->vs[j][i] += m1->vs[k][i] * m2->vs[j][k];
	//	}
	//}
}


/// Multiply a matrix by an axis-angle transformation matrix.
MATH_FN_ void double3x3axisangle(double3x3 *m, double3 axis, double angle) {
	memset(m->vs, 0, sizeof(m->vs));
	double a = angle, c = cos(a), s = sin(a);
	axis = double3norm(axis);
	double3 t = double3mul(axis, 1 - c);

	double r00 = c + t.x * axis.x;
	double r01 = t.x * axis.y + s * axis.z;
	double r02 = t.x * axis.z - s * axis.y;

	double r10 = t.y * axis.x - s * axis.z;
	double r11 = c + t.y * axis.y;
	double r12 = t.y * axis.z + s * axis.x;

	double r20 = t.z * axis.x + s * axis.y;
	double r21 = t.z * axis.y - s * axis.x;
	double r22 = c + t.z * axis.z;

	double3x3 r;
	r.v3s[0] = double3add(double3add(double3mul(m->v3s[0], r00), double3mul(m->v3s[1], r01)), double3mul(m->v3s[2], r02));
	r.v3s[1] = double3add(double3add(double3mul(m->v3s[0], r10), double3mul(m->v3s[1], r11)), double3mul(m->v3s[2], r12));
	r.v3s[2] = double3add(double3add(double3mul(m->v3s[0], r20), double3mul(m->v3s[1], r21)), double3mul(m->v3s[2], r22));
	*m = r;
}
/// Create a 3x3 Euler angles rotation matrix.
MATH_FN_ void setdouble3x3rotation(double3x3 *m, double yaw, double pitch, double roll) {
	memset(m->vs, 0, sizeof(m->vs));
	double α = pitch, β = yaw, γ = roll;
	double sα = sin(α), sβ = sin(β), sγ = sin(γ);
	double cα = cos(α), cβ = cos(β), cγ = cos(γ);

	m->vs[0][0] = cβ * cγ;
	m->vs[1][0] = cβ * sγ;
	m->vs[2][0] = -sβ;
	m->vs[0][1] = sα * sβ * cγ - cα * sγ;
	m->vs[1][1] = sα * sβ * sγ + cα * cγ;
	m->vs[2][1] = sα * cβ;
	m->vs[0][2] = cα * sβ * cγ + sα * sγ;
	m->vs[1][2] = cα * sβ * sγ - sα * cγ;
	m->vs[2][2] = cα * cβ;
}
	
/// Create a 3x3 rotation matrix from a rotor.
MATH_FN_ void setdouble3x3rotationR(double3x3 *m, doubleR r) {
	m->v3s[0] = doubleRapply(r, double3xyz(1, 0, 0));
	m->v3s[1] = doubleRapply(r, double3xyz(0, 1, 0));
	m->v3s[2] = doubleRapply(r, double3xyz(0, 0, 1));
}

/// Create a 3x3 translation matrix.
MATH_FN_ void double4x4trans(double4x4 *m, double3 d) {
	double r[4] = {};
	r[0] += m->vs[0][0] * d.x; r[1] += m->vs[0][1] * d.x; r[2] += m->vs[0][2] * d.x; r[3] += m->vs[0][3] * d.x;
	r[0] += m->vs[1][0] * d.y; r[1] += m->vs[1][1] * d.y; r[2] += m->vs[1][2] * d.y; r[3] += m->vs[1][3] * d.y;
	r[0] += m->vs[2][0] * d.z; r[1] += m->vs[2][1] * d.z; r[2] += m->vs[2][2] * d.z; r[3] += m->vs[2][3] * d.z;
	m->vs[3][0] += r[0]; m->vs[3][1] += r[1]; m->vs[3][2] += r[2]; m->vs[3][3] += r[3];
}

/// Create a 3x3 scale matrix.
MATH_FN_ void double4x4scale(double4x4 *m, double3 s) {
	m->vs[0][0] *= s.x;
	m->vs[0][1] *= s.y;
	m->vs[0][2] *= s.z;
	m->vs[1][0] *= s.x;
	m->vs[1][1] *= s.y;
	m->vs[1][2] *= s.z;
	m->vs[2][0] *= s.x;
	m->vs[2][1] *= s.y;
	m->vs[2][2] *= s.z;
	m->vs[3][0] *= s.x;
	m->vs[3][1] *= s.y;
	m->vs[3][2] *= s.z;
}

/// Information returned by the perspective
/// projection matrix functions.
struct double4x4persp_info {
	/// The near plane extents.
	double2 plane;
	/// The distance of the near plane from the origin.
	double znear;
};

/// Set the specified matrix to a right-handed reversed-z perspective projection matrix.
MATH_FN_ struct double4x4persp_info setdouble4x4persp_rhoz(double4x4 *m, double fov, double aspect, double znear, double zfar) {
	// https://gist.github.com/pezcode/1609b61a1eedd207ec8c5acf6f94f53a
	memset(m->vs, 0, sizeof(m->vs));
	struct double4x4persp_info info;
	double t = tan(fov * 0.5f * π / 180.0f);
	info.plane.y = t * znear;
	info.plane.x = info.plane.y * aspect;
	info.znear = znear;
	double k = znear / (znear - zfar);
	double g = 1.0 / t;
	m->vs[0][0] = g / aspect;
	m->vs[1][1] = -g;
	m->vs[2][2] = -k;
	m->vs[2][3] = 1.0;
	m->vs[3][2] = -znear * k;

	return info;
}

/// Set the specified matrix to a right-handed reversed-z infinite perspective projection matrix.
MATH_FN_ struct double4x4persp_info setdouble4x4persp_rhozi(double4x4 *m, double fov, double aspect, double znear) {
	// http://www.songho.ca/opengl/gl_projectionmatrix.html#perspective
	// https://computergraphics.stackexchange.com/a/12453
	// https://discourse.nphysics.org/t/reversed-z-and-infinite-zfar-in-projections/341/2
	memset(m->vs, 0, sizeof(m->vs));
	struct double4x4persp_info info;
	double t = tan(fov * 0.5f * π / 180.0f);
	info.plane.y = t * znear;
	info.plane.x = info.plane.y * aspect;
	info.znear = znear;
	double g = 1.0f / t;

	m->vs[0][0] = g / aspect;
	m->vs[1][1] = -g;
	m->vs[3][2] = znear;
	m->vs[2][3] = 1.0f;

	return info;
}

/// Set the specified matrix to a perspective projection matrix.
MATH_FN_ struct double4x4persp_info setdouble4x4persp(double4x4 *m, double fov, double aspect, double znear) {
	// return setdouble4x4persp_rhoz(m, fov, aspect, znear, (double)1000.0);
	return setdouble4x4persp_rhozi(m, fov, aspect, znear);
}

/// Set the specified matrix to a view matrix, looking at `center` from `eye`,
/// with `up` being the upwards direction.
MATH_FN_ void setdouble4x4lookat(double4x4 *m, double3 eye, double3 center, double3 up) {
	memset(m->vs, 0, sizeof(m->vs));
	double3 f = double3norm(double3sub(center, eye));
	double3 s = double3norm(double3cross(up, f));
	double3 u = double3cross(f, s);

	m->vs[0][0] = s.x;
	m->vs[1][0] = s.y;
	m->vs[2][0] = s.z;
	m->vs[0][1] = u.x;
	m->vs[1][1] = u.y;
	m->vs[2][1] = u.z;
	m->vs[0][2] = f.x;
	m->vs[1][2] = f.y;
	m->vs[2][2] = f.z;
	m->vs[3][0] = -double3dot(s, eye);
	m->vs[3][1] = -double3dot(u, eye);
	m->vs[3][2] = -double3dot(f, eye);
	m->vs[3][3] = 1.0f;
}


/// Create a float2 from a double2 with each component casted.
MATH_FN_ float2 float2_double2(double2 x) { return (float2){{ (float)(x.vs[0]), (float)(x.vs[1]) }}; }
/// Create a float3 from a double3 with each component casted.
MATH_FN_ float3 float3_double3(double3 x) { return (float3){{ (float)(x.vs[0]), (float)(x.vs[1]), (float)(x.vs[2]) }}; }
/// Create a float4 from a double4 with each component casted.
MATH_FN_ float4 float4_double4(double4 x) { return (float4){{ (float)(x.vs[0]), (float)(x.vs[1]), (float)(x.vs[2]), (float)(x.vs[3]) }}; }
/// Create a float2x2 from a double2x2 with each component casted.
MATH_FN_ float2x2 float2x2_double2x2(double2x2 x) { return (float2x2){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[1][0]), (float)(x.vs[1][1]) }}; }
/// Create a float2x3 from a double2x3 with each component casted.
MATH_FN_ float2x3 float2x3_double2x3(double2x3 x) { return (float2x3){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[0][2]), (float)(x.vs[1][0]), (float)(x.vs[1][1]), (float)(x.vs[1][2]) }}; }
/// Create a float2x4 from a double2x4 with each component casted.
MATH_FN_ float2x4 float2x4_double2x4(double2x4 x) { return (float2x4){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[0][2]), (float)(x.vs[0][3]), (float)(x.vs[1][0]), (float)(x.vs[1][1]), (float)(x.vs[1][2]), (float)(x.vs[1][3]) }}; }
/// Create a float3x2 from a double3x2 with each component casted.
MATH_FN_ float3x2 float3x2_double3x2(double3x2 x) { return (float3x2){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[1][0]), (float)(x.vs[1][1]), (float)(x.vs[2][0]), (float)(x.vs[2][1]) }}; }
/// Create a float3x3 from a double3x3 with each component casted.
MATH_FN_ float3x3 float3x3_double3x3(double3x3 x) { return (float3x3){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[0][2]), (float)(x.vs[1][0]), (float)(x.vs[1][1]), (float)(x.vs[1][2]), (float)(x.vs[2][0]), (float)(x.vs[2][1]), (float)(x.vs[2][2]) }}; }
/// Create a float3x4 from a double3x4 with each component casted.
MATH_FN_ float3x4 float3x4_double3x4(double3x4 x) { return (float3x4){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[0][2]), (float)(x.vs[0][3]), (float)(x.vs[1][0]), (float)(x.vs[1][1]), (float)(x.vs[1][2]), (float)(x.vs[1][3]), (float)(x.vs[2][0]), (float)(x.vs[2][1]), (float)(x.vs[2][2]), (float)(x.vs[2][3]) }}; }
/// Create a float4x2 from a double4x2 with each component casted.
MATH_FN_ float4x2 float4x2_double4x2(double4x2 x) { return (float4x2){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[1][0]), (float)(x.vs[1][1]), (float)(x.vs[2][0]), (float)(x.vs[2][1]), (float)(x.vs[3][0]), (float)(x.vs[3][1]) }}; }
/// Create a float4x3 from a double4x3 with each component casted.
MATH_FN_ float4x3 float4x3_double4x3(double4x3 x) { return (float4x3){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[0][2]), (float)(x.vs[1][0]), (float)(x.vs[1][1]), (float)(x.vs[1][2]), (float)(x.vs[2][0]), (float)(x.vs[2][1]), (float)(x.vs[2][2]), (float)(x.vs[3][0]), (float)(x.vs[3][1]), (float)(x.vs[3][2]) }}; }
/// Create a float4x4 from a double4x4 with each component casted.
MATH_FN_ float4x4 float4x4_double4x4(double4x4 x) { return (float4x4){{ (float)(x.vs[0][0]), (float)(x.vs[0][1]), (float)(x.vs[0][2]), (float)(x.vs[0][3]), (float)(x.vs[1][0]), (float)(x.vs[1][1]), (float)(x.vs[1][2]), (float)(x.vs[1][3]), (float)(x.vs[2][0]), (float)(x.vs[2][1]), (float)(x.vs[2][2]), (float)(x.vs[2][3]), (float)(x.vs[3][0]), (float)(x.vs[3][1]), (float)(x.vs[3][2]), (float)(x.vs[3][3]) }}; }
/// Create a double2 from a float2 with each component casted.
MATH_FN_ double2 double2_float2(float2 x) { return (double2){{ (double)(x.vs[0]), (double)(x.vs[1]) }}; }
/// Create a double3 from a float3 with each component casted.
MATH_FN_ double3 double3_float3(float3 x) { return (double3){{ (double)(x.vs[0]), (double)(x.vs[1]), (double)(x.vs[2]) }}; }
/// Create a double4 from a float4 with each component casted.
MATH_FN_ double4 double4_float4(float4 x) { return (double4){{ (double)(x.vs[0]), (double)(x.vs[1]), (double)(x.vs[2]), (double)(x.vs[3]) }}; }
/// Create a double2x2 from a float2x2 with each component casted.
MATH_FN_ double2x2 double2x2_float2x2(float2x2 x) { return (double2x2){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[1][0]), (double)(x.vs[1][1]) }}; }
/// Create a double2x3 from a float2x3 with each component casted.
MATH_FN_ double2x3 double2x3_float2x3(float2x3 x) { return (double2x3){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[0][2]), (double)(x.vs[1][0]), (double)(x.vs[1][1]), (double)(x.vs[1][2]) }}; }
/// Create a double2x4 from a float2x4 with each component casted.
MATH_FN_ double2x4 double2x4_float2x4(float2x4 x) { return (double2x4){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[0][2]), (double)(x.vs[0][3]), (double)(x.vs[1][0]), (double)(x.vs[1][1]), (double)(x.vs[1][2]), (double)(x.vs[1][3]) }}; }
/// Create a double3x2 from a float3x2 with each component casted.
MATH_FN_ double3x2 double3x2_float3x2(float3x2 x) { return (double3x2){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[1][0]), (double)(x.vs[1][1]), (double)(x.vs[2][0]), (double)(x.vs[2][1]) }}; }
/// Create a double3x3 from a float3x3 with each component casted.
MATH_FN_ double3x3 double3x3_float3x3(float3x3 x) { return (double3x3){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[0][2]), (double)(x.vs[1][0]), (double)(x.vs[1][1]), (double)(x.vs[1][2]), (double)(x.vs[2][0]), (double)(x.vs[2][1]), (double)(x.vs[2][2]) }}; }
/// Create a double3x4 from a float3x4 with each component casted.
MATH_FN_ double3x4 double3x4_float3x4(float3x4 x) { return (double3x4){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[0][2]), (double)(x.vs[0][3]), (double)(x.vs[1][0]), (double)(x.vs[1][1]), (double)(x.vs[1][2]), (double)(x.vs[1][3]), (double)(x.vs[2][0]), (double)(x.vs[2][1]), (double)(x.vs[2][2]), (double)(x.vs[2][3]) }}; }
/// Create a double4x2 from a float4x2 with each component casted.
MATH_FN_ double4x2 double4x2_float4x2(float4x2 x) { return (double4x2){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[1][0]), (double)(x.vs[1][1]), (double)(x.vs[2][0]), (double)(x.vs[2][1]), (double)(x.vs[3][0]), (double)(x.vs[3][1]) }}; }
/// Create a double4x3 from a float4x3 with each component casted.
MATH_FN_ double4x3 double4x3_float4x3(float4x3 x) { return (double4x3){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[0][2]), (double)(x.vs[1][0]), (double)(x.vs[1][1]), (double)(x.vs[1][2]), (double)(x.vs[2][0]), (double)(x.vs[2][1]), (double)(x.vs[2][2]), (double)(x.vs[3][0]), (double)(x.vs[3][1]), (double)(x.vs[3][2]) }}; }
/// Create a double4x4 from a float4x4 with each component casted.
MATH_FN_ double4x4 double4x4_float4x4(float4x4 x) { return (double4x4){{ (double)(x.vs[0][0]), (double)(x.vs[0][1]), (double)(x.vs[0][2]), (double)(x.vs[0][3]), (double)(x.vs[1][0]), (double)(x.vs[1][1]), (double)(x.vs[1][2]), (double)(x.vs[1][3]), (double)(x.vs[2][0]), (double)(x.vs[2][1]), (double)(x.vs[2][2]), (double)(x.vs[2][3]), (double)(x.vs[3][0]), (double)(x.vs[3][1]), (double)(x.vs[3][2]), (double)(x.vs[3][3]) }}; }

#endif // PSHINE_MATH_H_
