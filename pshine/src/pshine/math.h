// DO NOT EDIT; THIS FILE WAS GENERATED BY generate_math.py
#ifndef PSHINE_MATH_H_
#define PSHINE_MATH_H_
#include "pshine/util.h"
#include <stddef.h>
#include <string.h>
#include <math.h>

static const double π = 3.141592653589793;
static const double euler = 2.718281828459045;
static const double τ = 6.283185307179586;


// float lerp, min, max, clamp
static inline float minf(float a, float b) { return a < b ? a : b; }
static inline float maxf(float a, float b) { return a > b ? a : b; }
static inline float clampf(float x, float a, float b) { return minf(maxf(x, a), b); }
static inline float lerpf(float a, float b, float t) { return a * 1 - t + b * t; }

// float2 type
typedef union {
	struct { float x, y; };
	struct { float r, g; };
	float vs[2];
} float2;
	
static inline float2 float2xy(float x, float y) { return (float2){{ x, y }}; }
static inline float2 float2rg(float r, float g) { return (float2){{ r, g }}; }
static inline float2 float2vs(const float vs[2]) { return (float2){{ vs[0], vs[1] }}; }
static inline float2 float2v(float v) { return (float2){{ v, v }}; }
static inline float2 float2v0() { return float2v(0); }

// float2 operations
static inline float2 float2neg(float2 v) { return (float2){{ -v.vs[0], -v.vs[1] }}; }
static inline float2 float2add(float2 a, float2 b) { return (float2){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1] }}; }
static inline float2 float2sub(float2 a, float2 b) { return (float2){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1] }}; }
static inline float2 float2mul(float2 v, float s) { return (float2){{ v.vs[0] * s, v.vs[1] * s }}; }
static inline float2 float2div(float2 v, float s) { return (float2){{ v.vs[0] / s, v.vs[1] / s }}; }
static inline float float2dot(float2 a, float2 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1]; }
static inline float float2mag2(float2 v) { return float2dot(v, v); }
static inline float float2mag(float2 v) { return sqrtf(float2mag2(v)); }
static inline float2 float2norm(float2 v) {
	float m = float2mag2(v);
	if (fabsf(m) <= 0.0000001f) return (float2){};
	return float2div(v, sqrtf(m));
}

// float2 lerp, min, max, clamp
static inline float2 float2min(float2 a, float2 b) { return (float2){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1] }}; }
static inline float2 float2max(float2 a, float2 b) { return (float2){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1] }}; }
static inline float2 float2clamp(float2 x, float2 a, float2 b) { return float2min(float2max(x, a), b); }
static inline float2 float2lerp(float2 a, float2 b, float t) { return float2add(float2mul(a, 1 - t), float2mul(b, t)); }

// float3 type
typedef union {
	struct { float x, y, z; };
	struct { float r, g, b; };
	float vs[3];
} float3;
	
static inline float3 float3xyz(float x, float y, float z) { return (float3){{ x, y, z }}; }
static inline float3 float3rgb(float r, float g, float b) { return (float3){{ r, g, b }}; }
static inline float3 float3vs(const float vs[3]) { return (float3){{ vs[0], vs[1], vs[2] }}; }
static inline float3 float3v(float v) { return (float3){{ v, v, v }}; }
static inline float3 float3v0() { return float3v(0); }

// float3 operations
static inline float3 float3neg(float3 v) { return (float3){{ -v.vs[0], -v.vs[1], -v.vs[2] }}; }
static inline float3 float3add(float3 a, float3 b) { return (float3){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1], a.vs[2] + b.vs[2] }}; }
static inline float3 float3sub(float3 a, float3 b) { return (float3){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1], a.vs[2] - b.vs[2] }}; }
static inline float3 float3mul(float3 v, float s) { return (float3){{ v.vs[0] * s, v.vs[1] * s, v.vs[2] * s }}; }
static inline float3 float3div(float3 v, float s) { return (float3){{ v.vs[0] / s, v.vs[1] / s, v.vs[2] / s }}; }
static inline float float3dot(float3 a, float3 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1] + a.vs[2] * b.vs[2]; }
static inline float float3mag2(float3 v) { return float3dot(v, v); }
static inline float float3mag(float3 v) { return sqrtf(float3mag2(v)); }
static inline float3 float3norm(float3 v) {
	float m = float3mag2(v);
	if (fabsf(m) <= 0.0000001f) return (float3){};
	return float3div(v, sqrtf(m));
}

// float vector cross product
static inline float3 float3cross(float3 a, float3 b) {
	return float3xyz(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

// float3 lerp, min, max, clamp
static inline float3 float3min(float3 a, float3 b) { return (float3){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] < b.vs[2] ? a.vs[2] : b.vs[2] }}; }
static inline float3 float3max(float3 a, float3 b) { return (float3){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] > b.vs[2] ? a.vs[2] : b.vs[2] }}; }
static inline float3 float3clamp(float3 x, float3 a, float3 b) { return float3min(float3max(x, a), b); }
static inline float3 float3lerp(float3 a, float3 b, float t) { return float3add(float3mul(a, 1 - t), float3mul(b, t)); }

// float4 type
typedef union {
	struct { float x, y, z, w; };
	struct { float r, g, b, a; };
	float vs[4];
} float4;
	
static inline float4 float4xyzw(float x, float y, float z, float w) { return (float4){{ x, y, z, w }}; }
static inline float4 float4rgba(float r, float g, float b, float a) { return (float4){{ r, g, b, a }}; }
static inline float4 float4vs(const float vs[4]) { return (float4){{ vs[0], vs[1], vs[2], vs[3] }}; }
static inline float4 float4v(float v) { return (float4){{ v, v, v, v }}; }
static inline float4 float4v0() { return float4v(0); }

// float4 type
static inline float4 float4xyz3w(float3 xyz, float w) { return (float4){{ xyz.x, xyz.y, xyz.z, w }}; }

// float4 operations
static inline float4 float4neg(float4 v) { return (float4){{ -v.vs[0], -v.vs[1], -v.vs[2], -v.vs[3] }}; }
static inline float4 float4add(float4 a, float4 b) { return (float4){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1], a.vs[2] + b.vs[2], a.vs[3] + b.vs[3] }}; }
static inline float4 float4sub(float4 a, float4 b) { return (float4){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1], a.vs[2] - b.vs[2], a.vs[3] - b.vs[3] }}; }
static inline float4 float4mul(float4 v, float s) { return (float4){{ v.vs[0] * s, v.vs[1] * s, v.vs[2] * s, v.vs[3] * s }}; }
static inline float4 float4div(float4 v, float s) { return (float4){{ v.vs[0] / s, v.vs[1] / s, v.vs[2] / s, v.vs[3] / s }}; }
static inline float float4dot(float4 a, float4 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1] + a.vs[2] * b.vs[2] + a.vs[3] * b.vs[3]; }
static inline float float4mag2(float4 v) { return float4dot(v, v); }
static inline float float4mag(float4 v) { return sqrtf(float4mag2(v)); }
static inline float4 float4norm(float4 v) {
	float m = float4mag2(v);
	if (fabsf(m) <= 0.0000001f) return (float4){};
	return float4div(v, sqrtf(m));
}

// float4 lerp, min, max, clamp
static inline float4 float4min(float4 a, float4 b) { return (float4){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] < b.vs[2] ? a.vs[2] : b.vs[2], a.vs[3] < b.vs[3] ? a.vs[3] : b.vs[3] }}; }
static inline float4 float4max(float4 a, float4 b) { return (float4){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] > b.vs[2] ? a.vs[2] : b.vs[2], a.vs[3] > b.vs[3] ? a.vs[3] : b.vs[3] }}; }
static inline float4 float4clamp(float4 x, float4 a, float4 b) { return float4min(float4max(x, a), b); }
static inline float4 float4lerp(float4 a, float4 b, float t) { return float4add(float4mul(a, 1 - t), float4mul(b, t)); }

// float2x2 matrix
typedef union {
	struct { float vs[2][2]; };
	struct { float2 v2s[2]; };
} float2x2;

// float2x3 matrix
typedef union {
	struct { float vs[2][3]; };
	struct { float2 v2s[3]; };
} float2x3;

// float2x4 matrix
typedef union {
	struct { float vs[2][4]; };
	struct { float2 v2s[4]; };
} float2x4;

// float3x2 matrix
typedef union {
	struct { float vs[3][2]; };
	struct { float3 v3s[2]; };
} float3x2;

// float3x3 matrix
typedef union {
	struct { float vs[3][3]; };
	struct { float3 v3s[3]; };
} float3x3;

// float3x4 matrix
typedef union {
	struct { float vs[3][4]; };
	struct { float3 v3s[4]; };
} float3x4;

// float4x2 matrix
typedef union {
	struct { float vs[4][2]; };
	struct { float4 v4s[2]; };
} float4x2;

// float4x3 matrix
typedef union {
	struct { float vs[4][3]; };
	struct { float4 v4s[3]; };
} float4x3;

// float4x4 matrix
typedef union {
	struct { float vs[4][4]; };
	struct { float4 v4s[4]; };
} float4x4;

// float matrix operations

static inline void setfloat4x4iden(float4x4 *m) {
	memset(m->vs, 0, sizeof(m->vs));
	m->vs[0][0] = 1.0;
	m->vs[1][1] = 1.0;
	m->vs[2][2] = 1.0;
	m->vs[3][3] = 1.0;
}

static inline void float4x4trans(float4x4 *m, float3 d) {
	float r[4] = {};
	r[0] += m->vs[0][0] * d.x; r[1] += m->vs[0][1] * d.x; r[2] += m->vs[0][2] * d.x; r[3] += m->vs[0][3] * d.x;
	r[0] += m->vs[1][0] * d.y; r[1] += m->vs[1][1] * d.y; r[2] += m->vs[1][2] * d.y; r[3] += m->vs[1][3] * d.y;
	r[0] += m->vs[2][0] * d.z; r[1] += m->vs[2][1] * d.z; r[2] += m->vs[2][2] * d.z; r[3] += m->vs[2][3] * d.z;
	m->vs[3][0] += r[0]; m->vs[3][1] += r[1]; m->vs[3][2] += r[2]; m->vs[3][3] += r[3];
}

static inline void float4x4scale(float4x4 *m, float3 s) {
	m->vs[0][0] *= s.x;
	m->vs[0][1] *= s.y;
	m->vs[0][2] *= s.z;
	m->vs[1][0] *= s.x;
	m->vs[1][1] *= s.y;
	m->vs[1][2] *= s.z;
	m->vs[2][0] *= s.x;
	m->vs[2][1] *= s.y;
	m->vs[2][2] *= s.z;
	m->vs[3][0] *= s.x;
	m->vs[3][1] *= s.y;
	m->vs[3][2] *= s.z;
}

struct float4x4persp_info {
	float2 plane;
	float znear;
};

static inline struct float4x4persp_info setfloat4x4persp_rhoz(float4x4 *m, float fov, float aspect, float znear, float zfar) {
	// https://gist.github.com/pezcode/1609b61a1eedd207ec8c5acf6f94f53a
	memset(m->vs, 0, sizeof(m->vs));
	struct float4x4persp_info info;
	float t = tanf(fov * 0.5f * π / 180.0f);
	info.plane.y = t * znear;
	info.plane.x = info.plane.y * aspect;
	info.znear = znear;
	float k = znear / (znear - zfar);
	float g = 1.0 / t;
	m->vs[0][0] = g / aspect;
	m->vs[1][1] = -g;
	m->vs[2][2] = -k;
	m->vs[2][3] = 1.0;
	m->vs[3][2] = -znear * k;

	return info;
}

static inline struct float4x4persp_info setfloat4x4persp_rhozi(float4x4 *m, float fov, float aspect, float znear) {
	// http://www.songho.ca/opengl/gl_projectionmatrix.html#perspective
	// https://computergraphics.stackexchange.com/a/12453
	// https://discourse.nphysics.org/t/reversed-z-and-infinite-zfar-in-projections/341/2
	memset(m->vs, 0, sizeof(m->vs));
	struct float4x4persp_info info;
	float t = tanf(fov * 0.5f * π / 180.0f);
	info.plane.y = t * znear;
	info.plane.x = info.plane.y * aspect;
	info.znear = znear;
	float g = 1.0f / t;

	m->vs[0][0] = g / aspect;
	m->vs[1][1] = -g;
	m->vs[3][2] = znear;
	m->vs[2][3] = 1.0f;

	return info;
}

static inline struct float4x4persp_info setfloat4x4persp(float4x4 *m, float fov, float aspect, float znear) {
	// return setfloat4x4persp_rhoz(m, fov, aspect, znear, (float)1000.0);
	return setfloat4x4persp_rhozi(m, fov, aspect, znear);
}

static inline void setfloat4x4lookat(float4x4 *m, float3 eye, float3 center, float3 up) {
	memset(m->vs, 0, sizeof(m->vs));
	float3 f = float3norm(float3sub(center, eye));
	float3 s = float3norm(float3cross(up, f));
	float3 u = float3cross(f, s);

	m->vs[0][0] = s.x;
	m->vs[1][0] = s.y;
	m->vs[2][0] = s.z;
	m->vs[0][1] = u.x;
	m->vs[1][1] = u.y;
	m->vs[2][1] = u.z;
	m->vs[0][2] = f.x;
	m->vs[1][2] = f.y;
	m->vs[2][2] = f.z;
	m->vs[3][0] = -float3dot(s, eye);
	m->vs[3][1] = -float3dot(u, eye);
	m->vs[3][2] = -float3dot(f, eye);
	m->vs[3][3] = 1.0f;
}

static inline void float4x4mul(float4x4 *res, const float4x4 *m1, const float4x4 *m2) {
	for (size_t i = 0; i < 4; ++i) {
		for (size_t j = 0; j < 4; ++j) {
			res->vs[j][i] = 0;
			for (size_t k = 0; k < 4; ++k)
				res->vs[j][i] += m1->vs[k][i] * m2->vs[j][k];
		}
	}
}



// double lerp, min, max, clamp
static inline double mind(double a, double b) { return a < b ? a : b; }
static inline double maxd(double a, double b) { return a > b ? a : b; }
static inline double clampd(double x, double a, double b) { return mind(maxd(x, a), b); }
static inline double lerpd(double a, double b, double t) { return a * 1 - t + b * t; }

// double2 type
typedef union {
	struct { double x, y; };
	struct { double r, g; };
	double vs[2];
} double2;
	
static inline double2 double2xy(double x, double y) { return (double2){{ x, y }}; }
static inline double2 double2rg(double r, double g) { return (double2){{ r, g }}; }
static inline double2 double2vs(const double vs[2]) { return (double2){{ vs[0], vs[1] }}; }
static inline double2 double2v(double v) { return (double2){{ v, v }}; }
static inline double2 double2v0() { return double2v(0); }

// double2 operations
static inline double2 double2neg(double2 v) { return (double2){{ -v.vs[0], -v.vs[1] }}; }
static inline double2 double2add(double2 a, double2 b) { return (double2){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1] }}; }
static inline double2 double2sub(double2 a, double2 b) { return (double2){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1] }}; }
static inline double2 double2mul(double2 v, double s) { return (double2){{ v.vs[0] * s, v.vs[1] * s }}; }
static inline double2 double2div(double2 v, double s) { return (double2){{ v.vs[0] / s, v.vs[1] / s }}; }
static inline double double2dot(double2 a, double2 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1]; }
static inline double double2mag2(double2 v) { return double2dot(v, v); }
static inline double double2mag(double2 v) { return sqrt(double2mag2(v)); }
static inline double2 double2norm(double2 v) {
	double m = double2mag2(v);
	if (fabs(m) <= 0.00000001) return (double2){};
	return double2div(v, sqrt(m));
}

// double2 lerp, min, max, clamp
static inline double2 double2min(double2 a, double2 b) { return (double2){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1] }}; }
static inline double2 double2max(double2 a, double2 b) { return (double2){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1] }}; }
static inline double2 double2clamp(double2 x, double2 a, double2 b) { return double2min(double2max(x, a), b); }
static inline double2 double2lerp(double2 a, double2 b, double t) { return double2add(double2mul(a, 1 - t), double2mul(b, t)); }

// double3 type
typedef union {
	struct { double x, y, z; };
	struct { double r, g, b; };
	double vs[3];
} double3;
	
static inline double3 double3xyz(double x, double y, double z) { return (double3){{ x, y, z }}; }
static inline double3 double3rgb(double r, double g, double b) { return (double3){{ r, g, b }}; }
static inline double3 double3vs(const double vs[3]) { return (double3){{ vs[0], vs[1], vs[2] }}; }
static inline double3 double3v(double v) { return (double3){{ v, v, v }}; }
static inline double3 double3v0() { return double3v(0); }

// double3 operations
static inline double3 double3neg(double3 v) { return (double3){{ -v.vs[0], -v.vs[1], -v.vs[2] }}; }
static inline double3 double3add(double3 a, double3 b) { return (double3){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1], a.vs[2] + b.vs[2] }}; }
static inline double3 double3sub(double3 a, double3 b) { return (double3){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1], a.vs[2] - b.vs[2] }}; }
static inline double3 double3mul(double3 v, double s) { return (double3){{ v.vs[0] * s, v.vs[1] * s, v.vs[2] * s }}; }
static inline double3 double3div(double3 v, double s) { return (double3){{ v.vs[0] / s, v.vs[1] / s, v.vs[2] / s }}; }
static inline double double3dot(double3 a, double3 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1] + a.vs[2] * b.vs[2]; }
static inline double double3mag2(double3 v) { return double3dot(v, v); }
static inline double double3mag(double3 v) { return sqrt(double3mag2(v)); }
static inline double3 double3norm(double3 v) {
	double m = double3mag2(v);
	if (fabs(m) <= 0.00000001) return (double3){};
	return double3div(v, sqrt(m));
}

// double vector cross product
static inline double3 double3cross(double3 a, double3 b) {
	return double3xyz(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

// double3 lerp, min, max, clamp
static inline double3 double3min(double3 a, double3 b) { return (double3){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] < b.vs[2] ? a.vs[2] : b.vs[2] }}; }
static inline double3 double3max(double3 a, double3 b) { return (double3){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] > b.vs[2] ? a.vs[2] : b.vs[2] }}; }
static inline double3 double3clamp(double3 x, double3 a, double3 b) { return double3min(double3max(x, a), b); }
static inline double3 double3lerp(double3 a, double3 b, double t) { return double3add(double3mul(a, 1 - t), double3mul(b, t)); }

// double4 type
typedef union {
	struct { double x, y, z, w; };
	struct { double r, g, b, a; };
	double vs[4];
} double4;
	
static inline double4 double4xyzw(double x, double y, double z, double w) { return (double4){{ x, y, z, w }}; }
static inline double4 double4rgba(double r, double g, double b, double a) { return (double4){{ r, g, b, a }}; }
static inline double4 double4vs(const double vs[4]) { return (double4){{ vs[0], vs[1], vs[2], vs[3] }}; }
static inline double4 double4v(double v) { return (double4){{ v, v, v, v }}; }
static inline double4 double4v0() { return double4v(0); }

// double4 type
static inline double4 double4xyz3w(double3 xyz, double w) { return (double4){{ xyz.x, xyz.y, xyz.z, w }}; }

// double4 operations
static inline double4 double4neg(double4 v) { return (double4){{ -v.vs[0], -v.vs[1], -v.vs[2], -v.vs[3] }}; }
static inline double4 double4add(double4 a, double4 b) { return (double4){{ a.vs[0] + b.vs[0], a.vs[1] + b.vs[1], a.vs[2] + b.vs[2], a.vs[3] + b.vs[3] }}; }
static inline double4 double4sub(double4 a, double4 b) { return (double4){{ a.vs[0] - b.vs[0], a.vs[1] - b.vs[1], a.vs[2] - b.vs[2], a.vs[3] - b.vs[3] }}; }
static inline double4 double4mul(double4 v, double s) { return (double4){{ v.vs[0] * s, v.vs[1] * s, v.vs[2] * s, v.vs[3] * s }}; }
static inline double4 double4div(double4 v, double s) { return (double4){{ v.vs[0] / s, v.vs[1] / s, v.vs[2] / s, v.vs[3] / s }}; }
static inline double double4dot(double4 a, double4 b) { return a.vs[0] * b.vs[0] + a.vs[1] * b.vs[1] + a.vs[2] * b.vs[2] + a.vs[3] * b.vs[3]; }
static inline double double4mag2(double4 v) { return double4dot(v, v); }
static inline double double4mag(double4 v) { return sqrt(double4mag2(v)); }
static inline double4 double4norm(double4 v) {
	double m = double4mag2(v);
	if (fabs(m) <= 0.00000001) return (double4){};
	return double4div(v, sqrt(m));
}

// double4 lerp, min, max, clamp
static inline double4 double4min(double4 a, double4 b) { return (double4){{ a.vs[0] < b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] < b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] < b.vs[2] ? a.vs[2] : b.vs[2], a.vs[3] < b.vs[3] ? a.vs[3] : b.vs[3] }}; }
static inline double4 double4max(double4 a, double4 b) { return (double4){{ a.vs[0] > b.vs[0] ? a.vs[0] : b.vs[0], a.vs[1] > b.vs[1] ? a.vs[1] : b.vs[1], a.vs[2] > b.vs[2] ? a.vs[2] : b.vs[2], a.vs[3] > b.vs[3] ? a.vs[3] : b.vs[3] }}; }
static inline double4 double4clamp(double4 x, double4 a, double4 b) { return double4min(double4max(x, a), b); }
static inline double4 double4lerp(double4 a, double4 b, double t) { return double4add(double4mul(a, 1 - t), double4mul(b, t)); }

// double2x2 matrix
typedef union {
	struct { double vs[2][2]; };
	struct { double2 v2s[2]; };
} double2x2;

// double2x3 matrix
typedef union {
	struct { double vs[2][3]; };
	struct { double2 v2s[3]; };
} double2x3;

// double2x4 matrix
typedef union {
	struct { double vs[2][4]; };
	struct { double2 v2s[4]; };
} double2x4;

// double3x2 matrix
typedef union {
	struct { double vs[3][2]; };
	struct { double3 v3s[2]; };
} double3x2;

// double3x3 matrix
typedef union {
	struct { double vs[3][3]; };
	struct { double3 v3s[3]; };
} double3x3;

// double3x4 matrix
typedef union {
	struct { double vs[3][4]; };
	struct { double3 v3s[4]; };
} double3x4;

// double4x2 matrix
typedef union {
	struct { double vs[4][2]; };
	struct { double4 v4s[2]; };
} double4x2;

// double4x3 matrix
typedef union {
	struct { double vs[4][3]; };
	struct { double4 v4s[3]; };
} double4x3;

// double4x4 matrix
typedef union {
	struct { double vs[4][4]; };
	struct { double4 v4s[4]; };
} double4x4;

// double matrix operations

static inline void setdouble4x4iden(double4x4 *m) {
	memset(m->vs, 0, sizeof(m->vs));
	m->vs[0][0] = 1.0;
	m->vs[1][1] = 1.0;
	m->vs[2][2] = 1.0;
	m->vs[3][3] = 1.0;
}

static inline void double4x4trans(double4x4 *m, double3 d) {
	double r[4] = {};
	r[0] += m->vs[0][0] * d.x; r[1] += m->vs[0][1] * d.x; r[2] += m->vs[0][2] * d.x; r[3] += m->vs[0][3] * d.x;
	r[0] += m->vs[1][0] * d.y; r[1] += m->vs[1][1] * d.y; r[2] += m->vs[1][2] * d.y; r[3] += m->vs[1][3] * d.y;
	r[0] += m->vs[2][0] * d.z; r[1] += m->vs[2][1] * d.z; r[2] += m->vs[2][2] * d.z; r[3] += m->vs[2][3] * d.z;
	m->vs[3][0] += r[0]; m->vs[3][1] += r[1]; m->vs[3][2] += r[2]; m->vs[3][3] += r[3];
}

static inline void double4x4scale(double4x4 *m, double3 s) {
	m->vs[0][0] *= s.x;
	m->vs[0][1] *= s.y;
	m->vs[0][2] *= s.z;
	m->vs[1][0] *= s.x;
	m->vs[1][1] *= s.y;
	m->vs[1][2] *= s.z;
	m->vs[2][0] *= s.x;
	m->vs[2][1] *= s.y;
	m->vs[2][2] *= s.z;
	m->vs[3][0] *= s.x;
	m->vs[3][1] *= s.y;
	m->vs[3][2] *= s.z;
}

struct double4x4persp_info {
	double2 plane;
	double znear;
};

static inline struct double4x4persp_info setdouble4x4persp_rhoz(double4x4 *m, double fov, double aspect, double znear, double zfar) {
	// https://gist.github.com/pezcode/1609b61a1eedd207ec8c5acf6f94f53a
	memset(m->vs, 0, sizeof(m->vs));
	struct double4x4persp_info info;
	double t = tan(fov * 0.5f * π / 180.0f);
	info.plane.y = t * znear;
	info.plane.x = info.plane.y * aspect;
	info.znear = znear;
	double k = znear / (znear - zfar);
	double g = 1.0 / t;
	m->vs[0][0] = g / aspect;
	m->vs[1][1] = -g;
	m->vs[2][2] = -k;
	m->vs[2][3] = 1.0;
	m->vs[3][2] = -znear * k;

	return info;
}

static inline struct double4x4persp_info setdouble4x4persp_rhozi(double4x4 *m, double fov, double aspect, double znear) {
	// http://www.songho.ca/opengl/gl_projectionmatrix.html#perspective
	// https://computergraphics.stackexchange.com/a/12453
	// https://discourse.nphysics.org/t/reversed-z-and-infinite-zfar-in-projections/341/2
	memset(m->vs, 0, sizeof(m->vs));
	struct double4x4persp_info info;
	double t = tan(fov * 0.5f * π / 180.0f);
	info.plane.y = t * znear;
	info.plane.x = info.plane.y * aspect;
	info.znear = znear;
	double g = 1.0f / t;

	m->vs[0][0] = g / aspect;
	m->vs[1][1] = -g;
	m->vs[3][2] = znear;
	m->vs[2][3] = 1.0f;

	return info;
}

static inline struct double4x4persp_info setdouble4x4persp(double4x4 *m, double fov, double aspect, double znear) {
	// return setdouble4x4persp_rhoz(m, fov, aspect, znear, (double)1000.0);
	return setdouble4x4persp_rhozi(m, fov, aspect, znear);
}

static inline void setdouble4x4lookat(double4x4 *m, double3 eye, double3 center, double3 up) {
	memset(m->vs, 0, sizeof(m->vs));
	double3 f = double3norm(double3sub(center, eye));
	double3 s = double3norm(double3cross(up, f));
	double3 u = double3cross(f, s);

	m->vs[0][0] = s.x;
	m->vs[1][0] = s.y;
	m->vs[2][0] = s.z;
	m->vs[0][1] = u.x;
	m->vs[1][1] = u.y;
	m->vs[2][1] = u.z;
	m->vs[0][2] = f.x;
	m->vs[1][2] = f.y;
	m->vs[2][2] = f.z;
	m->vs[3][0] = -double3dot(s, eye);
	m->vs[3][1] = -double3dot(u, eye);
	m->vs[3][2] = -double3dot(f, eye);
	m->vs[3][3] = 1.0f;
}

static inline void double4x4mul(double4x4 *res, const double4x4 *m1, const double4x4 *m2) {
	for (size_t i = 0; i < 4; ++i) {
		for (size_t j = 0; j < 4; ++j) {
			res->vs[j][i] = 0;
			for (size_t k = 0; k < 4; ++k)
				res->vs[j][i] += m1->vs[k][i] * m2->vs[j][k];
		}
	}
}


#endif // PSHINE_MATH_H_
